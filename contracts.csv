location,code
A.0000000000000000.DapperUtilityCoin,"import FungibleToken from 0x0

pub contract DapperUtilityCoin: FungibleToken {

    // Total supply of DapperUtilityCoins in existence
    pub var totalSupply: UFix64

    // Event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // Event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // Event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // Event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // Event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // Event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Event that is emitted when a new burner resource is created
    pub event BurnerCreated()

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // holds the balance of a users tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @DapperUtilityCoin.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            DapperUtilityCoin.totalSupply = DapperUtilityCoin.totalSupply - self.balance
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @FungibleToken.Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {
        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }

        // createNewBurner
        //
        // Function that creates and returns a new burner resource
        //
        pub fun createNewBurner(): @Burner {
            emit BurnerCreated()
            return <-create Burner()
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // the amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @DapperUtilityCoin.Vault {
            pre {
                amount > UFix64(0): ""Amount minted must be greater than zero""
                amount <= self.allowedAmount: ""Amount minted must be less than the allowed amount""
            }
            DapperUtilityCoin.totalSupply = DapperUtilityCoin.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    // Burner
    //
    // Resource object that token admin accounts can hold to burn tokens.
    //
    pub resource Burner {

        // burnTokens
        //
        // Function that destroys a Vault instance, effectively burning the tokens.
        //
        // Note: the burned tokens are automatically subtracted from the
        // total supply in the Vault destructor.
        //
        pub fun burnTokens(from: @FungibleToken.Vault) {
            let vault <- from as! @DapperUtilityCoin.Vault
            let amount = vault.balance
            destroy vault
            emit TokensBurned(amount: amount)
        }
    }

    init() {
        // we're using a high value as the balance here to make it look like we've got a ton of money,
        // just in case some contract manually checks that our balance is sufficient to pay for stuff
        self.totalSupply = 999999999.0

        let admin <- create Administrator()
        let minter <- admin.createNewMinter(allowedAmount: self.totalSupply)
        self.account.save(<-admin, to: /storage/dapperUtilityCoinAdmin)

        // mint tokens
        let tokenVault <- minter.mintTokens(amount: self.totalSupply)
        self.account.save(<-tokenVault, to: /storage/dapperUtilityCoinVault)
        destroy minter

        // Create a public capability to the stored Vault that only exposes
        // the `balance` field through the `Balance` interface
        self.account.link<&DapperUtilityCoin.Vault{FungibleToken.Balance}>(
            /public/dapperUtilityCoinBalance,
            target: /storage/dapperUtilityCoinVault
        )

        // Create a public capability to the stored Vault that only exposes
        // the `deposit` method through the `Receiver` interface
        self.account.link<&{FungibleToken.Receiver}>(
            /public/dapperUtilityCoinReceiver,
            target: /storage/dapperUtilityCoinVault
        )

        // Emit an event that shows that the contract was initialized
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}"
A.0000000000000000.FiatToken,"import Crypto
import FungibleToken from 0x0
import OnChainMultiSig from 0x0

pub contract FiatToken: FungibleToken {

    // ------- FiatToken Events -------

    // Admin events    
    pub event AdminCreated(resourceId: UInt64)
    pub event AdminChanged(address: Address, resourceId: UInt64)

    // Owner events
    pub event OwnerCreated(resourceId: UInt64)
    pub event OwnerChanged(address: Address, resourceId: UInt64)

    // MasterMinter events
    pub event MasterMinterCreated(resourceId: UInt64)
    pub event MasterMinterChanged(address: Address, resourceId: UInt64)
    
    // Pauser events
    pub event Paused()
    pub event Unpaused()
    pub event PauserCreated(resourceId: UInt64)
    pub event PauserChanged(address: Address, resourceId: UInt64)
    
    // Blocklister events
    pub event Blocklisted(resourceId: UInt64)
    pub event Unblocklisted(resourceId: UInt64)
    pub event BlocklisterCreated(resourceId: UInt64)
    pub event BlocklisterChanged(address: Address, resourceId: UInt64)
    
    // FiatToken.Vault events
    pub event NewVault(resourceId: UInt64)
    pub event DestroyVault(resourceId: UInt64)
    pub event FiatTokenWithdrawn(amount: UFix64, from: UInt64)
    pub event FiatTokenDeposited(amount: UFix64, to: UInt64)

    // Minting events
    pub event MinterCreated(resourceId: UInt64)
    pub event MinterControllerCreated(resourceId: UInt64)
    pub event Mint(minter: UInt64, amount: UFix64)
    pub event Burn(minter: UInt64, amount: UFix64)
    pub event MinterConfigured(controller: UInt64, minter: UInt64, allowance: UFix64)
    pub event MinterRemoved(controller: UInt64, minter: UInt64)
    pub event ControllerConfigured(controller: UInt64, minter: UInt64)
    pub event ControllerRemoved(controller: UInt64)


    // ------- FungibleToken Events -------

    pub event TokensInitialized(initialSupply: UFix64)
    pub event TokensWithdrawn(amount: UFix64, from: Address?)
    pub event TokensDeposited(amount: UFix64, to: Address?)


    // ------- FiatToken Paths -------

    pub let VaultStoragePath: StoragePath
    pub let VaultBalancePubPath: PublicPath
    pub let VaultUUIDPubPath: PublicPath
    pub let VaultReceiverPubPath: PublicPath

    pub let BlocklistExecutorStoragePath: StoragePath

    pub let BlocklisterStoragePath: StoragePath
    pub let BlocklisterCapReceiverPubPath: PublicPath
    pub let BlocklisterUUIDPubPath: PublicPath
    pub let BlocklisterPubSigner: PublicPath

    pub let PauseExecutorStoragePath: StoragePath

    pub let PauserStoragePath: StoragePath
    pub let PauserCapReceiverPubPath: PublicPath
    pub let PauserUUIDPubPath: PublicPath
    pub let PauserPubSigner: PublicPath

    pub let AdminExecutorStoragePath: StoragePath

    pub let AdminStoragePath: StoragePath
    pub let AdminCapReceiverPubPath: PublicPath
    pub let AdminUUIDPubPath: PublicPath
    pub let AdminPubSigner: PublicPath

    pub let OwnerExecutorStoragePath: StoragePath

    pub let OwnerStoragePath: StoragePath
    pub let OwnerCapReceiverPubPath: PublicPath
    pub let OwnerUUIDPubPath: PublicPath
    pub let OwnerPubSigner: PublicPath

    pub let MasterMinterExecutorStoragePath: StoragePath

    pub let MasterMinterStoragePath: StoragePath
    pub let MasterMinterCapReceiverPubPath: PublicPath
    pub let MasterMinterUUIDPubPath: PublicPath
    pub let MasterMinterPubSigner: PublicPath

    pub let MinterControllerStoragePath: StoragePath
    pub let MinterControllerUUIDPubPath: PublicPath
    pub let MinterControllerPubSigner: PublicPath

    pub let MinterStoragePath: StoragePath
    pub let MinterUUIDPubPath: PublicPath


    // ------- FiatToken States / Variables -------

    pub let name: String
    pub var version: String
    // Set to true if the contract is paused
    pub var paused: Bool
    // The token total supply
    pub var totalSupply: UFix64
    // Blocked resources dictionary {resourceId: Block Height}
    access(contract) let blocklist: {UInt64: UInt64}
    // Managed minters dictionary {MinterController: Minter}
    access(contract) let managedMinters: {UInt64: UInt64}
    // Minter allowance dictionary {Minter: Allowance}
    access(contract) let minterAllowances: { UInt64: UFix64}
    

    // ------- FiatToken Interfaces  -------

    pub resource interface ResourceId {
        pub fun UUID(): UInt64
    }

    pub resource interface AdminCapReceiver {
        pub fun setAdminCap(cap: Capability<&AdminExecutor>)
    }

    pub resource interface OwnerCapReceiver {
        pub fun setOwnerCap(cap: Capability<&OwnerExecutor>)
    }

    pub resource interface MasterMinterCapReceiver {
        pub fun setMasterMinterCap(cap: Capability<&MasterMinterExecutor>)
    }

    pub resource interface BlocklisterCapReceiver {
        pub fun setBlocklistCap(cap: Capability<&BlocklistExecutor>)
    }

    pub resource interface PauseCapReceiver {
        pub fun setPauseCap(cap: Capability<&PauseExecutor>)
    }

    
    // ------- Path linking -------

    access(contract) fun linkAdminExec(_ newPrivPath: PrivatePath): Capability<&AdminExecutor>  {
        return self.account.link<&AdminExecutor>(newPrivPath, target: FiatToken.AdminExecutorStoragePath)
            ?? panic(""could not create new AdminExecutor capability link"")
    }

    access(contract) fun linkOwnerExec(_ newPrivPath: PrivatePath): Capability<&OwnerExecutor>  {
        return self.account.link<&OwnerExecutor>(newPrivPath, target: FiatToken.OwnerExecutorStoragePath)
            ?? panic(""could not create new OwnerExecutor capability link"")
    }

    access(contract) fun linkMasterMinterExec(_ newPrivPath: PrivatePath): Capability<&MasterMinterExecutor>  {
        return self.account.link<&MasterMinterExecutor>(newPrivPath, target: FiatToken.MasterMinterExecutorStoragePath)
            ?? panic(""could not create new MasterMinterExecutor capability link"")
    }

    access(contract) fun linkBlocklistExec(_ newPrivPath: PrivatePath): Capability<&FiatToken.BlocklistExecutor>  {
        return self.account.link<&BlocklistExecutor>(newPrivPath, target: FiatToken.BlocklistExecutorStoragePath)
            ?? panic(""could not create new BlocklistExecutor capability link"")
    }

    access(contract) fun linkPauserExec(_ newPrivPath: PrivatePath): Capability<&FiatToken.PauseExecutor>  {
        return self.account.link<&FiatToken.PauseExecutor>(newPrivPath, target: FiatToken.PauseExecutorStoragePath)
            ?? panic(""could not create new PauseExecutor capability link"")
    }

    // ------- Path unlinking -------

    access(contract) fun unlinkPriv(_ privPath: PrivatePath) {
        self.account.unlink(privPath)
    }


    // ------- FiatToken Resources -------

    pub resource Vault:
        ResourceId,
        FungibleToken.Provider,
        FungibleToken.Receiver,
        FungibleToken.Balance {
        
        pub var balance: UFix64

        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            pre {
                !FiatToken.paused: ""FiatToken contract paused""
                FiatToken.blocklist[self.uuid] == nil: ""Vault Blocklisted""
            }
            self.balance = self.balance - amount
            emit FiatTokenWithdrawn(amount: amount, from: self.uuid)
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        pub fun deposit(from: @FungibleToken.Vault) {
            pre {
                !FiatToken.paused: ""FiatToken contract paused""
                FiatToken.blocklist[from.uuid] == nil: ""Receiving Vault Blocklisted""
                FiatToken.blocklist[self.uuid] == nil: ""Vault Blocklisted""
            }
            let vault <- from as! @FiatToken.Vault
            self.balance = self.balance + vault.balance
            emit FiatTokenDeposited(amount: vault.balance, to: self.uuid)
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        access(contract) fun burn() {
            pre {
                self.balance > 0.0: ""Cannot burn USDC Vault with zero balance""
            }
            FiatToken.totalSupply = FiatToken.totalSupply - self.balance
            self.balance = 0.0
        }

        destroy() {
            pre {
                self.balance == 0.0: ""Cannot destroy USDC Vault with non-zero balance""
            }
            emit DestroyVault(resourceId: self.uuid)
        }

        init(balance: UFix64) {
            self.balance = balance
        }

    }

    pub resource AdminExecutor {

        access(self) var currentCapPath: PrivatePath?

        pub fun upgradeContract(name: String, code: [UInt8], version: String) {
            FiatToken.upgradeContract(name: name, code: code, version: version)
        }

        pub fun changeAdmin(to: Address, newPath: PrivatePath) {
            let newCap = FiatToken.linkAdminExec(newPath)
            let receiver = getAccount(to)
                .getCapability<&Admin{AdminCapReceiver}>(FiatToken.AdminCapReceiverPubPath)
                .borrow() ?? panic(""could not borrow AdminCapReceiver capability"")
            let idRef = getAccount(to)
                .getCapability<&Admin{ResourceId}>(FiatToken.AdminUUIDPubPath)
                .borrow() ?? panic(""could not borrow Admin ResourceId capability"")
            receiver.setAdminCap(cap: newCap)
            if self.currentCapPath != nil {
                FiatToken.unlinkPriv(self.currentCapPath!)
            }
            self.currentCapPath = newPath
            emit AdminChanged(address: to, resourceId: idRef.UUID())
        }

        init () {
            self.currentCapPath = nil
        }

    }

    pub resource Admin: OnChainMultiSig.PublicSigner, ResourceId, AdminCapReceiver {

        access(self) let multiSigManager: @OnChainMultiSig.Manager
        access(self) var adminExecutorCapability: Capability<&AdminExecutor>?

        pub fun setAdminCap(cap: Capability<&AdminExecutor>) {
            pre {
                self.adminExecutorCapability == nil: ""Capability has already been set""
                cap.borrow() != nil: ""Invalid capability""
            }
            self.adminExecutorCapability = cap
        }

        // ------- OnChainMultiSig.PublicSigner interfaces -------

        pub fun addNewPayload(payload: @OnChainMultiSig.PayloadDetails, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addNewPayload(resourceId: self.uuid, payload: <-payload, publicKey: publicKey, sig: sig)
        }

        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addPayloadSignature(resourceId: self.uuid, txIndex: txIndex, publicKey: publicKey, sig: sig)
        }

        pub fun executeTx(txIndex: UInt64): @AnyResource? {
            let p <- self.multiSigManager.readyForExecution(txIndex: txIndex) ?? panic (""no ready transaction payload at given txIndex"")
            switch p.method {
                case ""configureKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    let weight = p.getArg(i: 1)! as? UFix64 ?? panic (""cannot downcast weight"")
                    let sa = p.getArg(i: 2)! as? UInt8 ?? panic (""cannot downcast sig algo"")
                    self.multiSigManager.configureKeys(pks: [pubKey], kws: [weight], sa: [sa])
                case ""removeKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    self.multiSigManager.removeKeys(pks: [pubKey])
                case ""removePayload"":
                    let txIndex = p.getArg(i: 0)! as? UInt64 ?? panic (""cannot downcast txIndex"")
                    let payloadToRemove <- self.multiSigManager.removePayload(txIndex: txIndex)
                    destroy(payloadToRemove)
                case ""upgradeContract"":
                    let name = p.getArg(i: 0)! as? String ?? panic (""cannot downcast contract name"")
                    let code = p.getArg(i: 1)! as? String ?? panic (""cannot downcast contract code"")
                    let version = p.getArg(i: 2)! as? String ?? panic (""cannot downcast contract version"")
                    let executor = self.adminExecutorCapability!.borrow() ?? panic(""cannot borrow AdminExecutor capability"")
                    executor.upgradeContract(name: name, code: code.decodeHex(), version: version)
                case ""changeAdmin"":
                    let to = p.getArg(i: 0)! as? Address ?? panic(""cannot downcast receiver address"")
                    let path = p.getArg(i: 1)! as? PrivatePath ?? panic(""cannot downcast new link path"")
                    let executor = self.adminExecutorCapability!.borrow() ?? panic(""cannot borrow AdminExecutor capability"")
                    executor.changeAdmin(to: to, newPath: path)
                default:
                    panic(""Unknown transaction method"")
            }
            destroy (p)
            return nil
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        pub fun getTxIndex(): UInt64 {
            return self.multiSigManager.txIndex
        }

        pub fun getSignerKeys(): [String] {
            return self.multiSigManager.getSignerKeys()
        }

        pub fun getSignerKeyAttr(publicKey: String): OnChainMultiSig.PubKeyAttr? {
            return self.multiSigManager.getSignerKeyAttr(publicKey: publicKey)
        }

        destroy() {
            destroy self.multiSigManager
        }

        init(pk: [String], pka: [OnChainMultiSig.PubKeyAttr]) {
            self.multiSigManager <-  OnChainMultiSig.createMultiSigManager(publicKeys: pk, pubKeyAttrs: pka)
            self.adminExecutorCapability = nil
        }

    }

    pub resource OwnerExecutor {

        access(self) var ownerCapPath: PrivatePath?
        access(self) var masterMinterCapPath: PrivatePath?
        access(self) var blocklisterCapPath: PrivatePath?
        access(self) var pauserCapPath: PrivatePath?

        pub fun reassignOwner(to: Address, newPath: PrivatePath) {
            let newCap = FiatToken.linkOwnerExec(newPath)
            let receiver = getAccount(to)
                .getCapability<&Owner{OwnerCapReceiver}>(FiatToken.OwnerCapReceiverPubPath)
                .borrow() ?? panic(""could not borrow the OwnerCapReceiver capability"")
            let idRef = getAccount(to)
                .getCapability<&Owner{ResourceId}>(FiatToken.OwnerUUIDPubPath)
                .borrow() ?? panic(""could not borrow the Owner ResourceId capability"")
            receiver.setOwnerCap(cap: newCap)
            if self.ownerCapPath != nil {
                FiatToken.unlinkPriv(self.ownerCapPath!)
            }
            self.ownerCapPath = newPath
            emit OwnerChanged(address: to, resourceId: idRef.UUID())
        }

        pub fun reassignMasterMinter(to: Address, newPath: PrivatePath) {
            let newCap = FiatToken.linkMasterMinterExec(newPath)
            let receiver = getAccount(to)
                .getCapability<&MasterMinter{MasterMinterCapReceiver}>(FiatToken.MasterMinterCapReceiverPubPath)
                .borrow() ?? panic(""could not borrow the MasterMinterCapReceiver capability"")
            let idRef = getAccount(to)
                .getCapability<&MasterMinter{ResourceId}>(FiatToken.MasterMinterUUIDPubPath)
                .borrow() ?? panic(""could not borrow the MasterMinter ResourceId capability"")    
            receiver.setMasterMinterCap(cap: newCap)
            if self.masterMinterCapPath != nil {
                FiatToken.unlinkPriv(self.masterMinterCapPath!)
            }
            self.masterMinterCapPath = newPath
            emit MasterMinterChanged(address: to, resourceId: idRef.UUID())
        }

        pub fun reassignBlocklister(to: Address, newPath: PrivatePath) {
            let newCap = FiatToken.linkBlocklistExec(newPath)
            let receiver = getAccount(to)
                .getCapability<&Blocklister{BlocklisterCapReceiver}>(FiatToken.BlocklisterCapReceiverPubPath)
                .borrow() ?? panic(""could not borrow the BlocklisterCapReceiver capability "")
            let idRef = getAccount(to)
                .getCapability<&Blocklister{ResourceId}>(FiatToken.BlocklisterUUIDPubPath)
                .borrow() ?? panic(""could not borrow the Blocklister ResourceId capability"")  
            receiver.setBlocklistCap(cap: newCap)
            if self.blocklisterCapPath != nil {
                FiatToken.unlinkPriv(self.blocklisterCapPath!)
            }
            self.blocklisterCapPath = newPath
            emit BlocklisterChanged(address: to, resourceId: idRef.UUID())
        }

        pub fun reassignPauser(to: Address, newPath: PrivatePath) {
            let newCap = FiatToken.linkPauserExec(newPath)
            let receiver = getAccount(to)
                .getCapability<&Pauser{PauseCapReceiver}>(FiatToken.PauserCapReceiverPubPath)
                .borrow() ?? panic(""could not borrow the PauseCapReceiver capability"")
            let idRef = getAccount(to)
                .getCapability<&Pauser{ResourceId}>(FiatToken.PauserUUIDPubPath)
                .borrow() ?? panic(""could not borrow the Pauser ResourceId capability"") 
            receiver.setPauseCap(cap: newCap)
            if self.pauserCapPath != nil {
                FiatToken.unlinkPriv(self.pauserCapPath!)
            }
            self.pauserCapPath = newPath
            emit PauserChanged(address: to, resourceId: idRef.UUID())
        }

        init() {
            self.ownerCapPath = nil
            self.masterMinterCapPath = nil
            self.blocklisterCapPath = nil
            self.pauserCapPath = nil
        }

    }

    pub resource Owner: OnChainMultiSig.PublicSigner, ResourceId, OwnerCapReceiver {

        access(self) let multiSigManager: @OnChainMultiSig.Manager
        access(self) var ownerExecutorCapability: Capability<&OwnerExecutor>?

        pub fun setOwnerCap(cap: Capability<&OwnerExecutor>) {
            pre {
                self.ownerExecutorCapability == nil: ""Capability has already been set""
                cap.borrow() != nil: ""Invalid capability""
            }
            self.ownerExecutorCapability = cap
        }

        // ------- OnChainMultiSig.PublicSigner interfaces -------

        pub fun addNewPayload(payload: @OnChainMultiSig.PayloadDetails, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addNewPayload(resourceId: self.uuid, payload: <-payload, publicKey: publicKey, sig: sig)
        }

        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addPayloadSignature(resourceId: self.uuid, txIndex: txIndex, publicKey: publicKey, sig: sig)
        }

        pub fun executeTx(txIndex: UInt64): @AnyResource? {
            let p <- self.multiSigManager.readyForExecution(txIndex: txIndex) ?? panic (""no ready transaction payload at given txIndex"")
            switch p.method {
                case ""configureKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    let weight = p.getArg(i: 1)! as? UFix64 ?? panic (""cannot downcast weight"")
                    let sa = p.getArg(i: 2)! as? UInt8 ?? panic (""cannot downcast sig algo"")
                    self.multiSigManager.configureKeys(pks: [pubKey], kws: [weight], sa: [sa])
                case ""removeKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    self.multiSigManager.removeKeys(pks: [pubKey])
                case ""reassignOwner"":
                    let to = p.getArg(i: 0)! as? Address ?? panic(""cannot downcast receiver address"")
                    let path = p.getArg(i: 1)! as? PrivatePath ?? panic(""cannot downcast new link path"")
                    let executor = self.ownerExecutorCapability!.borrow() ?? panic(""cannot borrow OwnerExecutor capability"")
                    executor.reassignOwner(to: to, newPath: path)
                case ""reassignMasterMinter"":
                    let to = p.getArg(i: 0)! as? Address ?? panic(""cannot downcast receiver address"")
                    let path = p.getArg(i: 1)! as? PrivatePath ?? panic(""cannot downcast new link path"")
                    let executor = self.ownerExecutorCapability!.borrow() ?? panic(""cannot borrow OwnerExecutor capability"")
                    executor.reassignMasterMinter(to: to, newPath: path)
                case ""reassignBlocklister"":
                    let to = p.getArg(i: 0)! as? Address ?? panic(""cannot downcast receiver address"")
                    let path = p.getArg(i: 1)! as? PrivatePath ?? panic(""cannot downcast new link path"")
                    let executor = self.ownerExecutorCapability!.borrow() ?? panic(""cannot borrow OwnerExecutor capability"")
                    executor.reassignBlocklister(to: to, newPath: path)
                case ""reassignPauser"":
                    let to = p.getArg(i: 0)! as? Address ?? panic(""cannot downcast receiver address"")
                    let path = p.getArg(i: 1)! as? PrivatePath ?? panic(""cannot downcast new link path"")
                    let executor = self.ownerExecutorCapability!.borrow() ?? panic(""cannot borrow OwnerExecutor capability"")
                    executor.reassignPauser(to: to, newPath: path)
                default:
                    panic(""Unknown transaction method"")
            }
            destroy (p)
            return nil
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        pub fun getTxIndex(): UInt64 {
            return self.multiSigManager.txIndex
        }

        pub fun getSignerKeys(): [String] {
            return self.multiSigManager.getSignerKeys()
        }
        pub fun getSignerKeyAttr(publicKey: String): OnChainMultiSig.PubKeyAttr? {
            return self.multiSigManager.getSignerKeyAttr(publicKey: publicKey)
        }

        destroy() {
            destroy self.multiSigManager
        }

        init(pk: [String], pka: [OnChainMultiSig.PubKeyAttr]) {
            self.multiSigManager <-  OnChainMultiSig.createMultiSigManager(publicKeys: pk, pubKeyAttrs: pka)
            self.ownerExecutorCapability = nil
        }
    }

    pub resource MasterMinterExecutor {

        pub fun configureMinterController(minter: UInt64, minterController: UInt64) {
            // Overwrite the minter if the MinterController is already configured (a MinterController can only control 1 minter)
            FiatToken.managedMinters.insert(key: minterController, minter)
            emit ControllerConfigured(controller: minterController, minter: minter)
        }

        pub fun removeMinterController(minterController: UInt64){
            pre {
                FiatToken.managedMinters.containsKey(minterController): ""cannot remove unknown MinterController""
            }
            FiatToken.managedMinters.remove(key: minterController)
            emit ControllerRemoved(controller: minterController)
        }
    }

    pub resource MasterMinter: ResourceId, OnChainMultiSig.PublicSigner, MasterMinterCapReceiver {

        access(self) let multiSigManager: @OnChainMultiSig.Manager
        access(self) var masterMinterExecutorCapability: Capability<&MasterMinterExecutor>?

        pub fun setMasterMinterCap(cap: Capability<&MasterMinterExecutor>) {
            pre {
                self.masterMinterExecutorCapability == nil: ""Capability has already been set""
                cap.borrow() != nil: ""Invalid capability""
            }
            self.masterMinterExecutorCapability = cap
        }

        // ------- OnChainMultiSig.PublicSigner interfaces -------

        pub fun addNewPayload(payload: @OnChainMultiSig.PayloadDetails, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addNewPayload(resourceId: self.uuid, payload: <-payload, publicKey: publicKey, sig: sig)
        }

        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addPayloadSignature(resourceId: self.uuid, txIndex: txIndex, publicKey: publicKey, sig: sig)
        }

        pub fun executeTx(txIndex: UInt64): @AnyResource? {
            let p <- self.multiSigManager.readyForExecution(txIndex: txIndex) ?? panic (""no ready transaction payload at given txIndex"")
            switch p.method {
                case ""configureKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    let weight = p.getArg(i: 1)! as? UFix64 ?? panic (""cannot downcast weight"")
                    let sa = p.getArg(i: 2)! as? UInt8 ?? panic (""cannot downcast sig algo"")
                    self.multiSigManager.configureKeys(pks: [pubKey], kws: [weight], sa: [sa])
                case ""removeKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    self.multiSigManager.removeKeys(pks: [pubKey])
                case ""configureMinterController"":
                    let m = p.getArg(i: 0)! as? UInt64 ?? panic (""cannot downcast minter id"")
                    let mc = p.getArg(i: 1)! as? UInt64 ?? panic (""cannot downcast MinterController id"")
                    let executor = self.masterMinterExecutorCapability!.borrow() ?? panic(""cannot borrow MasterMinterExecutor capability"")
                    executor.configureMinterController(minter: m, minterController: mc)
                case ""removeMinterController"":
                    let mc = p.getArg(i: 0)! as? UInt64 ?? panic (""cannot downcast MinterController id"")
                    let executor = self.masterMinterExecutorCapability!.borrow() ?? panic(""cannot borrow MasterMinterExecutor capability"")
                    executor.removeMinterController(minterController: mc)
                default:
                    panic(""Unknown transaction method"")
            }
            destroy (p)
            return nil
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        pub fun getTxIndex(): UInt64 {
            return self.multiSigManager.txIndex
        }

        pub fun getSignerKeys(): [String] {
            return self.multiSigManager.getSignerKeys()
        }
        pub fun getSignerKeyAttr(publicKey: String): OnChainMultiSig.PubKeyAttr? {
            return self.multiSigManager.getSignerKeyAttr(publicKey: publicKey)
        }

        destroy() {
            destroy self.multiSigManager
        }

        init(pk: [String], pka: [OnChainMultiSig.PubKeyAttr]) {
            self.multiSigManager <-  OnChainMultiSig.createMultiSigManager(publicKeys: pk, pubKeyAttrs: pka)
            self.masterMinterExecutorCapability = nil
        }
    }

    pub resource MinterController: ResourceId, OnChainMultiSig.PublicSigner  {

        access(self) let multiSigManager: @OnChainMultiSig.Manager

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        pub fun configureMinterAllowance(allowance: UFix64) {
            let managedMinter = FiatToken.managedMinters[self.uuid] ?? panic(""MinterController does not manage any minters"")
            FiatToken.minterAllowances[managedMinter] = allowance
            emit MinterConfigured(controller: self.uuid, minter: managedMinter, allowance: allowance)
        }

        pub fun increaseMinterAllowance(increment: UFix64) {
            let managedMinter = FiatToken.managedMinters[self.uuid] ?? panic(""MinterController does not manage any minters"")
            let allowance = FiatToken.minterAllowances[managedMinter] ?? 0.0
            let newAllowance = allowance.saturatingAdd(increment)
            self.configureMinterAllowance(allowance: newAllowance)
        }

        pub fun decreaseMinterAllowance(decrement: UFix64) {
            let managedMinter = FiatToken.managedMinters[self.uuid] ?? panic(""MinterController does not manage any minters"")
            let allowance = FiatToken.minterAllowances[managedMinter] ?? panic(""Cannot decrease nil MinterAllowance"")
            let newAllowance = allowance!.saturatingSubtract(decrement)
            self.configureMinterAllowance(allowance: newAllowance)
        }

        pub fun removeMinter() {
            let managedMinter = FiatToken.managedMinters[self.uuid] ?? panic(""MinterController does not manage any minters"")
            assert(FiatToken.minterAllowances.containsKey(managedMinter), message: ""cannot remove unknown Minter"")
            FiatToken.minterAllowances.remove(key: managedMinter)
            emit MinterRemoved(controller: self.uuid, minter: managedMinter)
        }

        // ------- OnChainMultiSig.PublicSigner interfaces -------

        pub fun addNewPayload(payload: @OnChainMultiSig.PayloadDetails, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addNewPayload(resourceId: self.uuid, payload: <-payload, publicKey: publicKey, sig: sig)
        }

        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addPayloadSignature(resourceId: self.uuid, txIndex: txIndex, publicKey: publicKey, sig: sig)
        }

        pub fun executeTx(txIndex: UInt64): @AnyResource? {
            let p <- self.multiSigManager.readyForExecution(txIndex: txIndex) ?? panic (""no ready transaction payload at given txIndex"")
            switch p.method {
                case ""configureKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    let weight = p.getArg(i: 1)! as? UFix64 ?? panic (""cannot downcast weight"")
                    let sa = p.getArg(i: 2)! as? UInt8 ?? panic (""cannot downcast sig algo"")
                    self.multiSigManager.configureKeys(pks: [pubKey], kws: [weight], sa: [sa])
                case ""removeKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    self.multiSigManager.removeKeys(pks: [pubKey])
                case ""configureMinterAllowance"":
                    let allowance = p.getArg(i: 0)! as? UFix64 ?? panic (""cannot downcast allowance amount"")
                    self.configureMinterAllowance(allowance: allowance)
                case ""increaseMinterAllowance"":
                    let increment = p.getArg(i: 0)! as? UFix64 ?? panic (""cannot downcast increment amount"")
                    self.increaseMinterAllowance(increment: increment)
                case ""decreaseMinterAllowance"":
                    let decrement = p.getArg(i: 0)! as? UFix64 ?? panic (""cannot downcast decrement amount"")
                    self.decreaseMinterAllowance(decrement: decrement)
                case ""removeMinter"":
                    self.removeMinter()
                default:
                    panic(""Unknown transaction method"")
            }
            destroy (p)
            return nil
        }

        pub fun getTxIndex(): UInt64 {
            return self.multiSigManager.txIndex
        }

        pub fun getSignerKeys(): [String] {
            return self.multiSigManager.getSignerKeys()
        }

        pub fun getSignerKeyAttr(publicKey: String): OnChainMultiSig.PubKeyAttr? {
            return self.multiSigManager.getSignerKeyAttr(publicKey: publicKey)
        }

        destroy() {
            destroy self.multiSigManager
        }

        init(pk: [String], pka: [OnChainMultiSig.PubKeyAttr]) {
            self.multiSigManager <-  OnChainMultiSig.createMultiSigManager(publicKeys: pk, pubKeyAttrs: pka)
        }
    }

    pub resource Minter: ResourceId {

        pub fun mint(amount: UFix64): @FungibleToken.Vault{
            pre {
                !FiatToken.paused: ""FiatToken contract paused""
                FiatToken.blocklist[self.uuid] == nil: ""Minter Blocklisted""
                FiatToken.minterAllowances.containsKey(self.uuid): ""minter does not have allowance set""
            }
            let mintAllowance = FiatToken.minterAllowances[self.uuid]!
            assert(mintAllowance >= amount, message: ""insufficient mint allowance"")
            FiatToken.minterAllowances.insert(key: self.uuid, mintAllowance - amount)
            let newTotalSupply = FiatToken.totalSupply + amount
            FiatToken.totalSupply = newTotalSupply

            emit Mint(minter: self.uuid, amount: amount)
            return <-create Vault(balance: amount)
        }

        pub fun burn(vault: @FungibleToken.Vault) {
            pre {
                !FiatToken.paused: ""FiatToken contract paused""
                FiatToken.blocklist[self.uuid] == nil: ""Minter Blocklisted""
                FiatToken.minterAllowances.containsKey(self.uuid): ""minter is not configured""
            }
            let toBurn <- vault as! @FiatToken.Vault
            let amount = toBurn.balance

            assert(FiatToken.totalSupply >= amount, message: ""burning more than total supply"")

            // This function updates FiatToken.totalSupply and sets the Vault's value to 0.0
            toBurn.burn()
            // Destroys the now empty Vault
            destroy toBurn
            emit Burn(minter: self.uuid, amount: amount)
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }
    }

    pub resource BlocklistExecutor {
        
        pub fun blocklist(resourceId: UInt64){
            let block = getCurrentBlock()
            FiatToken.blocklist.insert(key: resourceId, block.height)
            emit Blocklisted(resourceId: resourceId)
        }

        pub fun unblocklist(resourceId: UInt64){
            FiatToken.blocklist.remove(key: resourceId)
            emit Unblocklisted(resourceId: resourceId)
        }
    }

    pub resource Blocklister: ResourceId, BlocklisterCapReceiver, OnChainMultiSig.PublicSigner {

        access(self) var blocklistCap: Capability<&BlocklistExecutor>?
        access(self) let multiSigManager: @OnChainMultiSig.Manager

        pub fun blocklist(resourceId: UInt64){
            post {
                FiatToken.blocklist.containsKey(resourceId): ""Resource not blocklisted""
            }
            self.blocklistCap!.borrow()!.blocklist(resourceId: resourceId)
        }

        pub fun unblocklist(resourceId: UInt64){
            post {
                !FiatToken.blocklist.containsKey(resourceId): ""Resource still on blocklist""
            }
            self.blocklistCap!.borrow()!.unblocklist(resourceId: resourceId)
        }

        pub fun setBlocklistCap(cap: Capability<&BlocklistExecutor>){
            pre {
                self.blocklistCap == nil: ""Capability has already been set""
                cap.borrow() != nil: ""Invalid BlocklistCap capability""
            }
            self.blocklistCap = cap
        }

        // ------- OnChainMultiSig.PublicSigner interfaces -------

        pub fun addNewPayload(payload: @OnChainMultiSig.PayloadDetails, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addNewPayload(resourceId: self.uuid, payload: <- payload, publicKey: publicKey, sig: sig)
        }

        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addPayloadSignature(resourceId: self.uuid, txIndex: txIndex, publicKey: publicKey, sig: sig)
        }

        pub fun executeTx(txIndex: UInt64): @AnyResource? {
            let p <- self.multiSigManager.readyForExecution(txIndex: txIndex) ?? panic (""no ready transaction payload at given txIndex"")
            switch p.method {
                case ""configureKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    let weight = p.getArg(i: 1)! as? UFix64 ?? panic (""cannot downcast weight"")
                    let sa = p.getArg(i: 2)! as? UInt8 ?? panic (""cannot downcast sig algo"")
                    self.multiSigManager.configureKeys(pks: [pubKey], kws: [weight], sa: [sa])
                case ""removeKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    self.multiSigManager.removeKeys(pks: [pubKey])
                case ""blocklist"":
                    let resourceId = p.getArg(i: 0)! as? UInt64 ?? panic (""cannot downcast resourceId"")
                    self.blocklist(resourceId: resourceId)
                case ""unblocklist"":
                    let resourceId = p.getArg(i: 0)! as? UInt64 ?? panic (""cannot downcast resourceId"")
                    self.unblocklist(resourceId: resourceId)
                default:
                    panic(""Unknown transaction method"")
            }
            destroy(p)
            return nil
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        pub fun getTxIndex(): UInt64 {
            return self.multiSigManager.txIndex
        }

        pub fun getSignerKeys(): [String] {
            return self.multiSigManager.getSignerKeys()
        }
        pub fun getSignerKeyAttr(publicKey: String): OnChainMultiSig.PubKeyAttr? {
            return self.multiSigManager.getSignerKeyAttr(publicKey: publicKey)
        }

        destroy() {
            destroy self.multiSigManager
        }

        init(pk: [String], pka: [OnChainMultiSig.PubKeyAttr]) {
            self.blocklistCap = nil
            self.multiSigManager <-  OnChainMultiSig.createMultiSigManager(publicKeys: pk, pubKeyAttrs: pka)
        }
    }

    pub resource PauseExecutor {

        pub fun pause() {
            FiatToken.paused = true
            emit Paused()
        }

        pub fun unpause() {
            FiatToken.paused = false
            emit Unpaused()
        }
    }

    pub resource Pauser: ResourceId, PauseCapReceiver, OnChainMultiSig.PublicSigner {
        
        access(self) var pauseCap:  Capability<&PauseExecutor>?
        access(self) let multiSigManager: @OnChainMultiSig.Manager

        pub fun setPauseCap(cap: Capability<&PauseExecutor>) {
            pre {
                self.pauseCap == nil: ""Capability has already been set""
                cap.borrow() != nil: ""Invalid PauseCap capability""
            }
            self.pauseCap = cap
        }

        pub fun pause(){
            let cap = self.pauseCap!.borrow()!
            cap.pause()
        }

        pub fun unpause(){
            let cap = self.pauseCap!.borrow()!
            cap.unpause()
        }

        // ------- OnChainMultiSig.PublicSigner interfaces -------

        pub fun addNewPayload(payload: @OnChainMultiSig.PayloadDetails, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addNewPayload(resourceId: self.uuid, payload: <- payload, publicKey: publicKey, sig: sig)
        }

        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            self.multiSigManager.addPayloadSignature(resourceId: self.uuid, txIndex: txIndex, publicKey: publicKey, sig: sig)
        }

        pub fun executeTx(txIndex: UInt64): @AnyResource? {
            let p <- self.multiSigManager.readyForExecution(txIndex: txIndex) ?? panic (""no ready transaction payload at given txIndex"")
            switch p.method {
                case ""configureKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    let weight = p.getArg(i: 1)! as? UFix64 ?? panic (""cannot downcast weight"")
                    let sa = p.getArg(i: 2)! as? UInt8 ?? panic (""cannot downcast sig algo"")
                    self.multiSigManager.configureKeys(pks: [pubKey], kws: [weight], sa: [sa])
                case ""removeKey"":
                    let pubKey = p.getArg(i: 0)! as? String ?? panic (""cannot downcast public key"")
                    self.multiSigManager.removeKeys(pks: [pubKey])
                case ""pause"":
                    self.pause()
                case ""unpause"":
                    self.unpause()
                default:
                    panic(""Unknown transaction method"")
            }
            destroy(p)
            return nil
        }

        pub fun UUID(): UInt64 {
            return self.uuid
        }

        pub fun getTxIndex(): UInt64 {
            return self.multiSigManager.txIndex
        }

        pub fun getSignerKeys(): [String] {
            return self.multiSigManager.getSignerKeys()
        }

        pub fun getSignerKeyAttr(publicKey: String): OnChainMultiSig.PubKeyAttr? {
            return self.multiSigManager.getSignerKeyAttr(publicKey: publicKey)
        }

        destroy() {
            destroy self.multiSigManager
        }

        init(pk: [String], pka: [OnChainMultiSig.PubKeyAttr]) {
            self.pauseCap = nil
            self.multiSigManager <-  OnChainMultiSig.createMultiSigManager(publicKeys: pk, pubKeyAttrs: pka)
        }
    }

    // ------- FiatToken functions -------

    pub fun createEmptyVault(): @Vault {
        let r <-create Vault(balance: 0.0)
        emit NewVault(resourceId: r.uuid)
        return <-r
    }

    pub fun createNewAdmin(publicKeys: [String], pubKeyAttrs: [OnChainMultiSig.PubKeyAttr]): @Admin{
        let admin <-create Admin(pk: publicKeys, pka: pubKeyAttrs)
        emit AdminCreated(resourceId: admin.uuid)
        return <- admin
    }

    pub fun createNewOwner(publicKeys: [String], pubKeyAttrs: [OnChainMultiSig.PubKeyAttr]): @Owner{
        let owner <-create Owner(pk: publicKeys, pka: pubKeyAttrs)
        emit OwnerCreated(resourceId: owner.uuid)
        return <- owner
    }

    pub fun createNewPauser(publicKeys: [String], pubKeyAttrs: [OnChainMultiSig.PubKeyAttr]): @Pauser{
        let pauser <-create Pauser(pk: publicKeys, pka: pubKeyAttrs)
        emit PauserCreated(resourceId: pauser.uuid)
        return <- pauser
    }

    pub fun createNewMasterMinter(publicKeys: [String], pubKeyAttrs: [OnChainMultiSig.PubKeyAttr]): @MasterMinter{
        let masterMinter <- create MasterMinter(pk: publicKeys, pka: pubKeyAttrs)
        emit MasterMinterCreated(resourceId: masterMinter.uuid)
        return <- masterMinter
    }

    pub fun createNewMinterController(publicKeys: [String], pubKeyAttrs: [OnChainMultiSig.PubKeyAttr]): @MinterController{
        let minterController <- create MinterController(pk: publicKeys, pka: pubKeyAttrs)
        emit MinterControllerCreated(resourceId: minterController.uuid)
        return <- minterController
    }

    pub fun createNewMinter(): @Minter{
        let minter <- create Minter()
        emit MinterCreated(resourceId: minter.uuid)
        return <- minter
    }

    pub fun createNewBlocklister(publicKeys: [String], pubKeyAttrs: [OnChainMultiSig.PubKeyAttr]): @Blocklister{
        let blocklister <-create Blocklister(pk: publicKeys, pka: pubKeyAttrs)
        emit BlocklisterCreated(resourceId: blocklister.uuid)
        return <-blocklister
    }

    pub fun getBlocklist(resourceId: UInt64): UInt64?{
        return FiatToken.blocklist[resourceId]
    }

    pub fun getManagedMinter(resourceId: UInt64): UInt64?{
        return FiatToken.managedMinters[resourceId]
    }

    pub fun getMinterAllowance(resourceId: UInt64): UFix64?{
        return FiatToken.minterAllowances[resourceId]
    }

    access(self) fun upgradeContract( name: String, code: [UInt8], version: String,) {
        self.account.contracts.update__experimental(name: name, code: code)
        self.version = version
    }

    // ------- FiatToken Initializer -------
    init(
        contractAccount: AuthAccount,
        VaultStoragePath: StoragePath,
        VaultBalancePubPath: PublicPath,
        VaultUUIDPubPath: PublicPath,
        VaultReceiverPubPath: PublicPath,
        BlocklistExecutorStoragePath: StoragePath,
        BlocklisterStoragePath: StoragePath,
        BlocklisterCapReceiverPubPath: PublicPath,
        BlocklisterUUIDPubPath: PublicPath,
        BlocklisterPubSigner: PublicPath,
        PauseExecutorStoragePath: StoragePath,
        PauserStoragePath: StoragePath,
        PauserCapReceiverPubPath: PublicPath,
        PauserUUIDPubPath: PublicPath,
        PauserPubSigner: PublicPath,
        AdminExecutorStoragePath: StoragePath,
        AdminStoragePath: StoragePath,
        AdminCapReceiverPubPath: PublicPath,
        AdminUUIDPubPath: PublicPath,
        AdminPubSigner: PublicPath,
        OwnerExecutorStoragePath: StoragePath,
        OwnerStoragePath: StoragePath,
        OwnerCapReceiverPubPath: PublicPath,
        OwnerUUIDPubPath: PublicPath,
        OwnerPubSigner: PublicPath,
        MasterMinterExecutorStoragePath: StoragePath,
        MasterMinterStoragePath: StoragePath,
        MasterMinterCapReceiverPubPath: PublicPath,
        MasterMinterPubSigner: PublicPath,
        MasterMinterUUIDPubPath: PublicPath,
        MinterControllerStoragePath: StoragePath,
        MinterControllerUUIDPubPath: PublicPath,
        MinterControllerPubSigner: PublicPath,
        MinterStoragePath: StoragePath,
        MinterUUIDPubPath: PublicPath,
        initialAdminCapabilityPrivPath: PrivatePath,
        initialOwnerCapabilityPrivPath: PrivatePath,
        initialMasterMinterCapabilityPrivPath: PrivatePath,
        initialPauserCapabilityPrivPath: PrivatePath,
        initialBlocklisterCapabilityPrivPath: PrivatePath,
        tokenName: String,
        version: String,
        initTotalSupply: UFix64,
        initPaused: Bool,
        adminPubKeys: [String],
        adminPubKeysWeights: [UFix64],
        adminPubKeysAlgos: [UInt8],
        ownerPubKeys: [String],
        ownerPubKeysWeights: [UFix64],
        ownerPubKeysAlgos: [UInt8],
        masterMinterPubKeys: [String],
        masterMinterPubKeysWeights: [UFix64],
        masterMinterPubKeysAlgos: [UInt8],
        blocklisterPubKeys: [String],
        blocklisterPubKeysWeights: [UFix64],
        blocklisterPubKeysAlgos: [UInt8],
        pauserPubKeys: [String],
        pauserPubKeysWeights: [UFix64],
        pauserPubKeysAlgos: [UInt8],
    ) {

        // Validate the keys
        assert(adminPubKeys.length == adminPubKeysWeights.length, message: ""Admin pub keys length and weights mismatched"")
        assert(ownerPubKeys.length == ownerPubKeysWeights.length, message: ""Owner pub keys length and weights mismatched"")
        assert(masterMinterPubKeys.length == masterMinterPubKeysWeights.length, message: ""MasterMinter pub keys length and weights mismatched"")
        assert(blocklisterPubKeys.length == blocklisterPubKeysWeights.length, message: ""Blocklister pub keys length and weights mismatched"")
        assert(pauserPubKeys.length == pauserPubKeysWeights.length, message: ""Pauser pub keys length and weights mismatched"")

        // Set the State
        self.name = tokenName
        self.version = version
        self.paused = initPaused
        self.totalSupply = initTotalSupply
        self.blocklist = {}
        self.minterAllowances = {}
        self.managedMinters = {}

        self.VaultStoragePath = VaultStoragePath
        self.VaultBalancePubPath = VaultBalancePubPath
        self.VaultUUIDPubPath = VaultUUIDPubPath
        self.VaultReceiverPubPath = VaultReceiverPubPath

        self.BlocklistExecutorStoragePath =  BlocklistExecutorStoragePath

        self.BlocklisterStoragePath =  BlocklisterStoragePath
        self.BlocklisterCapReceiverPubPath = BlocklisterCapReceiverPubPath
        self.BlocklisterUUIDPubPath = BlocklisterUUIDPubPath
        self.BlocklisterPubSigner = BlocklisterPubSigner

        self.PauseExecutorStoragePath = PauseExecutorStoragePath

        self.PauserStoragePath = PauserStoragePath
        self.PauserCapReceiverPubPath = PauserCapReceiverPubPath
        self.PauserUUIDPubPath = PauserUUIDPubPath
        self.PauserPubSigner = PauserPubSigner

        self.AdminExecutorStoragePath = AdminExecutorStoragePath

        self.AdminStoragePath = AdminStoragePath
        self.AdminCapReceiverPubPath = AdminCapReceiverPubPath
        self.AdminUUIDPubPath = AdminUUIDPubPath
        self.AdminPubSigner = AdminPubSigner

        self.OwnerExecutorStoragePath = OwnerExecutorStoragePath

        self.OwnerStoragePath = OwnerStoragePath
        self.OwnerCapReceiverPubPath = OwnerCapReceiverPubPath
        self.OwnerUUIDPubPath = OwnerUUIDPubPath
        self.OwnerPubSigner = OwnerPubSigner

        self.MasterMinterExecutorStoragePath = MasterMinterExecutorStoragePath

        self.MasterMinterStoragePath = MasterMinterStoragePath
        self.MasterMinterCapReceiverPubPath = MasterMinterCapReceiverPubPath
        self.MasterMinterPubSigner = MasterMinterPubSigner
        self.MasterMinterUUIDPubPath = MasterMinterUUIDPubPath

        self.MinterControllerStoragePath = MinterControllerStoragePath
        self.MinterControllerUUIDPubPath = MinterControllerUUIDPubPath
        self.MinterControllerPubSigner = MinterControllerPubSigner

        self.MinterStoragePath = MinterStoragePath
        self.MinterUUIDPubPath = MinterUUIDPubPath

        // Create admin accounts
        let adminAccount = AuthAccount(payer: contractAccount)
        let ownerAccount = AuthAccount(payer: contractAccount)
        let masterMinterAccount = AuthAccount(payer: contractAccount)
        let blocklisterAccount = AuthAccount(payer: contractAccount)
        let pauserAccount = AuthAccount(payer: contractAccount)
        
        // Create the Executors
        contractAccount.save(<- create AdminExecutor(), to: self.AdminExecutorStoragePath)
        contractAccount.save(<- create OwnerExecutor(), to: self.OwnerExecutorStoragePath)
        contractAccount.save(<- create MasterMinterExecutor(), to: self.MasterMinterExecutorStoragePath)
        contractAccount.save(<- create BlocklistExecutor(), to: self.BlocklistExecutorStoragePath)
        contractAccount.save(<- create PauseExecutor(), to: self.PauseExecutorStoragePath)

        // Setup the Admin
        var pubKeyAttrs: [OnChainMultiSig.PubKeyAttr] = []
        var i = 0
        while i < adminPubKeys.length {
            let pka = OnChainMultiSig.PubKeyAttr(sa: adminPubKeysAlgos[i], w: adminPubKeysWeights[i])
            pubKeyAttrs.append(pka)
            let key = PublicKey(
                publicKey: adminPubKeys[i].decodeHex(), 
                signatureAlgorithm: SignatureAlgorithm(rawValue: adminPubKeysAlgos[i]) ?? panic (""Invalid signature algo"")
            )
            adminAccount.keys.add(
                publicKey: key,
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: adminPubKeysWeights[i]
            )
            i = i + 1
        }
        adminAccount.save(<- self.createNewAdmin(publicKeys: adminPubKeys, pubKeyAttrs: pubKeyAttrs), to: self.AdminStoragePath)
        adminAccount.link<&Admin{OnChainMultiSig.PublicSigner}>(self.AdminPubSigner, target: self.AdminStoragePath)
        adminAccount.link<&Admin{ResourceId}>(self.AdminUUIDPubPath, target: self.AdminStoragePath)
        adminAccount.link<&Admin{AdminCapReceiver}>(self.AdminCapReceiverPubPath, target: self.AdminStoragePath)

        // Setup the Owner
        pubKeyAttrs = []
        i = 0
        while i < ownerPubKeys.length {
            let pka = OnChainMultiSig.PubKeyAttr(sa: ownerPubKeysAlgos[i], w: ownerPubKeysWeights[i])
            pubKeyAttrs.append(pka)
            let key = PublicKey(
                publicKey: ownerPubKeys[i].decodeHex(), 
                signatureAlgorithm: SignatureAlgorithm(rawValue: ownerPubKeysAlgos[i]) ?? panic (""Invalid signature algo"")
            )
            ownerAccount.keys.add(
                publicKey: key,
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: ownerPubKeysWeights[i]
            )
            i = i + 1
        }
        ownerAccount.save(<- self.createNewOwner(publicKeys: ownerPubKeys, pubKeyAttrs: pubKeyAttrs), to: self.OwnerStoragePath)
        ownerAccount.link<&Owner{OnChainMultiSig.PublicSigner}>(self.OwnerPubSigner, target: self.OwnerStoragePath)
        ownerAccount.link<&Owner{ResourceId}>(self.OwnerUUIDPubPath, target: self.OwnerStoragePath)
        ownerAccount.link<&Owner{OwnerCapReceiver}>(self.OwnerCapReceiverPubPath, target: self.OwnerStoragePath)

        // Setup the MasterMinter
        pubKeyAttrs = []
        i = 0
        while i < masterMinterPubKeys.length {
            let pka = OnChainMultiSig.PubKeyAttr(sa: masterMinterPubKeysAlgos[i], w: masterMinterPubKeysWeights[i])
            pubKeyAttrs.append(pka)
            let key = PublicKey(
                publicKey: masterMinterPubKeys[i].decodeHex(), 
                signatureAlgorithm: SignatureAlgorithm(rawValue: masterMinterPubKeysAlgos[i]) ?? panic (""Invalid signature algo"")
            )
            masterMinterAccount.keys.add(
                publicKey: key,
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: masterMinterPubKeysWeights[i]
            )
            i = i + 1
        }
        masterMinterAccount.save(<- self.createNewMasterMinter(publicKeys: masterMinterPubKeys, pubKeyAttrs: pubKeyAttrs), to: self.MasterMinterStoragePath)
        masterMinterAccount.link<&MasterMinter{OnChainMultiSig.PublicSigner}>(self.MasterMinterPubSigner, target: self.MasterMinterStoragePath)
        masterMinterAccount.link<&MasterMinter{ResourceId}>(self.MasterMinterUUIDPubPath, target: self.MasterMinterStoragePath)
        masterMinterAccount.link<&MasterMinter{MasterMinterCapReceiver}>(self.MasterMinterCapReceiverPubPath, target: self.MasterMinterStoragePath)

        // Setup the Blocklister 
        pubKeyAttrs = []
        i = 0
        while i < blocklisterPubKeys.length {
            let pka = OnChainMultiSig.PubKeyAttr(sa: blocklisterPubKeysAlgos[i], w: blocklisterPubKeysWeights[i])
            pubKeyAttrs.append(pka)
            let key = PublicKey(
                publicKey: blocklisterPubKeys[i].decodeHex(), 
                signatureAlgorithm: SignatureAlgorithm(rawValue: blocklisterPubKeysAlgos[i]) ?? panic (""Invalid signature algo"")
            )
            blocklisterAccount.keys.add(
                publicKey: key,
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: blocklisterPubKeysWeights[i]
            )
            i = i + 1
        }
        blocklisterAccount.save(<- self.createNewBlocklister(publicKeys: blocklisterPubKeys, pubKeyAttrs: pubKeyAttrs), to: self.BlocklisterStoragePath)
        blocklisterAccount.link<&Blocklister{OnChainMultiSig.PublicSigner}>(self.BlocklisterPubSigner, target: self.BlocklisterStoragePath)
        blocklisterAccount.link<&Blocklister{ResourceId}>(self.BlocklisterUUIDPubPath, target: self.BlocklisterStoragePath)
        blocklisterAccount.link<&Blocklister{BlocklisterCapReceiver}>(self.BlocklisterCapReceiverPubPath, target: self.BlocklisterStoragePath)

        // Setup the Pauser
        pubKeyAttrs = []
        i = 0
        while i < pauserPubKeys.length {
            let pka = OnChainMultiSig.PubKeyAttr(sa: pauserPubKeysAlgos[i], w: pauserPubKeysWeights[i])
            pubKeyAttrs.append(pka)
            let key = PublicKey(
                publicKey: pauserPubKeys[i].decodeHex(), 
                signatureAlgorithm: SignatureAlgorithm(rawValue: pauserPubKeysAlgos[i]) ?? panic (""Invalid signature algo"")
            )
            pauserAccount.keys.add(
                publicKey: key,
                hashAlgorithm: HashAlgorithm.SHA3_256,
                weight: pauserPubKeysWeights[i]
            )
            i = i + 1
        }
        pauserAccount.save(<- self.createNewPauser(publicKeys: pauserPubKeys, pubKeyAttrs: pubKeyAttrs), to: self.PauserStoragePath)
        pauserAccount.link<&Pauser{OnChainMultiSig.PublicSigner}>(self.PauserPubSigner, target: self.PauserStoragePath)
        pauserAccount.link<&Pauser{ResourceId}>(self.PauserUUIDPubPath, target: self.PauserStoragePath)
        pauserAccount.link<&Pauser{PauseCapReceiver}>(self.PauserCapReceiverPubPath, target: self.PauserStoragePath)

        // Assign the admin capabilities
        let adminExecutorRef = contractAccount.borrow<&FiatToken.AdminExecutor>(from: self.AdminExecutorStoragePath)
            ?? panic(""cannot borrow AdminExecutor from storage"")
        let ownerExecutorRef = contractAccount.borrow<&FiatToken.OwnerExecutor>(from: self.OwnerExecutorStoragePath)
            ?? panic(""cannot borrow OwnerExecutor from storage"")
        adminExecutorRef.changeAdmin(to: adminAccount.address, newPath: initialAdminCapabilityPrivPath)
        ownerExecutorRef.reassignOwner(to: ownerAccount.address, newPath: initialOwnerCapabilityPrivPath)
        ownerExecutorRef.reassignMasterMinter(to: masterMinterAccount.address, newPath: initialMasterMinterCapabilityPrivPath)
        ownerExecutorRef.reassignBlocklister(to: blocklisterAccount.address, newPath: initialBlocklisterCapabilityPrivPath)
        ownerExecutorRef.reassignPauser(to: pauserAccount.address, newPath: initialPauserCapabilityPrivPath) 

        // Create a Vault with the initial totalSupply
        let vault <- create Vault(balance: self.totalSupply)
        self.account.save(<-vault, to: self.VaultStoragePath)

        // Create public capabilities to the vault
        contractAccount.link<&FiatToken.Vault{FungibleToken.Receiver}>(self.VaultReceiverPubPath, target: self.VaultStoragePath)
        contractAccount.link<&FiatToken.Vault{FungibleToken.Balance}>(self.VaultBalancePubPath, target: self.VaultStoragePath)
        contractAccount.link<&FiatToken.Vault{FiatToken.ResourceId}>(self.VaultUUIDPubPath, target: self.VaultStoragePath)

        // Emit the TokensInitialized event
        emit TokensInitialized(initialSupply: self.totalSupply)

    }

}"
A.0000000000000000.NFTStorefront,"import FungibleToken from 0x0
import NonFungibleToken from 0x0

// NFTStorefront
//
// A general purpose sale support contract for Flow NonFungibleTokens.
// 
// Each account that wants to list NFTs for sale installs a Storefront,
// and lists individual sales within that Storefront as Listings.
// There is one Storefront per account, it handles sales of all NFT types
// for that account.
//
// Each Listing can have one or more ""cut""s of the sale price that
// goes to one or more addresses. Cuts can be used to pay listing fees
// or other considerations.
// Each NFT may be listed in one or more Listings, the validity of each
// Listing can easily be checked.
// 
// Purchasers can watch for Listing events and check the NFT type and
// ID to see if they wish to buy the listed item.
// Marketplaces and other aggregators can watch for Listing events
// and list items of interest.
//
pub contract NFTStorefront {
    // NFTStorefrontInitialized
    // This contract has been deployed.
    // Event consumers can now expect events from this contract.
    //
    pub event NFTStorefrontInitialized()

    // StorefrontInitialized
    // A Storefront resource has been created.
    // Event consumers can now expect events from this Storefront.
    // Note that we do not specify an address: we cannot and should not.
    // Created resources do not have an owner address, and may be moved
    // after creation in ways we cannot check.
    // ListingAvailable events can be used to determine the address
    // of the owner of the Storefront (...its location) at the time of
    // the listing but only at that precise moment in that precise transaction.
    // If the seller moves the Storefront while the listing is valid, 
    // that is on them.
    //
    pub event StorefrontInitialized(storefrontResourceID: UInt64)

    // StorefrontDestroyed
    // A Storefront has been destroyed.
    // Event consumers can now stop processing events from this Storefront.
    // Note that we do not specify an address.
    //
    pub event StorefrontDestroyed(storefrontResourceID: UInt64)

    // ListingAvailable
    // A listing has been created and added to a Storefront resource.
    // The Address values here are valid when the event is emitted, but
    // the state of the accounts they refer to may be changed outside of the
    // NFTStorefront workflow, so be careful to check when using them.
    //
    pub event ListingAvailable(
        storefrontAddress: Address,
        listingResourceID: UInt64,
        nftType: Type,
        nftID: UInt64,
        ftVaultType: Type,
        price: UFix64
    )

    // ListingCompleted
    // The listing has been resolved. It has either been purchased, or removed and destroyed.
    //
    pub event ListingCompleted(listingResourceID: UInt64, storefrontResourceID: UInt64, purchased: Bool)

    // StorefrontStoragePath
    // The location in storage that a Storefront resource should be located.
    pub let StorefrontStoragePath: StoragePath

    // StorefrontPublicPath
    // The public location for a Storefront link.
    pub let StorefrontPublicPath: PublicPath


    // SaleCut
    // A struct representing a recipient that must be sent a certain amount
    // of the payment when a token is sold.
    //
    pub struct SaleCut {
        // The receiver for the payment.
        // Note that we do not store an address to find the Vault that this represents,
        // as the link or resource that we fetch in this way may be manipulated,
        // so to find the address that a cut goes to you must get this struct and then
        // call receiver.borrow()!.owner.address on it.
        // This can be done efficiently in a script.
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        // The amount of the payment FungibleToken that will be paid to the receiver.
        pub let amount: UFix64

        // initializer
        //
        init(receiver: Capability<&{FungibleToken.Receiver}>, amount: UFix64) {
            self.receiver = receiver
            self.amount = amount
        }
    }


    // ListingDetails
    // A struct containing a Listing's data.
    //
    pub struct ListingDetails {
        // The Storefront that the Listing is stored in.
        // Note that this resource cannot be moved to a different Storefront,
        // so this is OK. If we ever make it so that it *can* be moved,
        // this should be revisited.
        pub var storefrontID: UInt64
        // Whether this listing has been purchased or not.
        pub var purchased: Bool
        // The Type of the NonFungibleToken.NFT that is being listed.
        pub let nftType: Type
        // The ID of the NFT within that type.
        pub let nftID: UInt64
        // The Type of the FungibleToken that payments must be made in.
        pub let salePaymentVaultType: Type
        // The amount that must be paid in the specified FungibleToken.
        pub let salePrice: UFix64
        // This specifies the division of payment between recipients.
        pub let saleCuts: [SaleCut]

        // setToPurchased
        // Irreversibly set this listing as purchased.
        //
        access(contract) fun setToPurchased() {
            self.purchased = true
        }

        // initializer
        //
        init (
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            storefrontID: UInt64
        ) {
            self.storefrontID = storefrontID
            self.purchased = false
            self.nftType = nftType
            self.nftID = nftID
            self.salePaymentVaultType = salePaymentVaultType

            // Store the cuts
            assert(saleCuts.length > 0, message: ""Listing must have at least one payment cut recipient"")
            self.saleCuts = saleCuts

            // Calculate the total price from the cuts
            var salePrice = 0.0
            // Perform initial check on capabilities, and calculate sale price from cut amounts.
            for cut in self.saleCuts {
                // Make sure we can borrow the receiver.
                // We will check this again when the token is sold.
                cut.receiver.borrow()
                    ?? panic(""Cannot borrow receiver"")
                // Add the cut amount to the total price
                salePrice = salePrice + cut.amount
            }
            assert(salePrice > 0.0, message: ""Listing must have non-zero price"")

            // Store the calculated sale price
            self.salePrice = salePrice
        }
    }


    // ListingPublic
    // An interface providing a useful public interface to a Listing.
    //
    pub resource interface ListingPublic {
        // borrowNFT
        // This will assert in the same way as the NFT standard borrowNFT()
        // if the NFT is absent, for example if it has been sold via another listing.
        //
        pub fun borrowNFT(): &NonFungibleToken.NFT

        // purchase
        // Purchase the listing, buying the token.
        // This pays the beneficiaries and returns the token to the buyer.
        //
        pub fun purchase(payment: @FungibleToken.Vault): @NonFungibleToken.NFT

        // getDetails
        //
        pub fun getDetails(): ListingDetails
    }


    // Listing
    // A resource that allows an NFT to be sold for an amount of a given FungibleToken,
    // and for the proceeds of that sale to be split between several recipients.
    // 
    pub resource Listing: ListingPublic {
        // The simple (non-Capability, non-complex) details of the sale
        access(self) let details: ListingDetails

        // A capability allowing this resource to withdraw the NFT with the given ID from its collection.
        // This capability allows the resource to withdraw *any* NFT, so you should be careful when giving
        // such a capability to a resource and always check its code to make sure it will use it in the
        // way that it claims.
        access(contract) let nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>

        // borrowNFT
        // This will assert in the same way as the NFT standard borrowNFT()
        // if the NFT is absent, for example if it has been sold via another listing.
        //
        pub fun borrowNFT(): &NonFungibleToken.NFT {
            let ref = self.nftProviderCapability.borrow()!.borrowNFT(id: self.getDetails().nftID)
            //- CANNOT DO THIS IN PRECONDITION: ""member of restricted type is not accessible: isInstance""
            //  result.isInstance(self.getDetails().nftType): ""token has wrong type""
            assert(ref.isInstance(self.getDetails().nftType), message: ""token has wrong type"")
            assert(ref.id == self.getDetails().nftID, message: ""token has wrong ID"")
            return ref as &NonFungibleToken.NFT
        }

        // getDetails
        // Get the details of the current state of the Listing as a struct.
        // This avoids having more public variables and getter methods for them, and plays
        // nicely with scripts (which cannot return resources).
        //
        pub fun getDetails(): ListingDetails {
            return self.details
        }

        // purchase
        // Purchase the listing, buying the token.
        // This pays the beneficiaries and returns the token to the buyer.
        //
        pub fun purchase(payment: @FungibleToken.Vault): @NonFungibleToken.NFT {
            pre {
                self.details.purchased == false: ""listing has already been purchased""
                payment.isInstance(self.details.salePaymentVaultType): ""payment vault is not requested fungible token""
                payment.balance == self.details.salePrice: ""payment vault does not contain requested price""
            }

            // Make sure the listing cannot be purchased again.
            self.details.setToPurchased()

            // Fetch the token to return to the purchaser.
            let nft <-self.nftProviderCapability.borrow()!.withdraw(withdrawID: self.details.nftID)
            // Neither receivers nor providers are trustworthy, they must implement the correct
            // interface but beyond complying with its pre/post conditions they are not gauranteed
            // to implement the functionality behind the interface in any given way.
            // Therefore we cannot trust the Collection resource behind the interface,
            // and we must check the NFT resource it gives us to make sure that it is the correct one.
            assert(nft.isInstance(self.details.nftType), message: ""withdrawn NFT is not of specified type"")
            assert(nft.id == self.details.nftID, message: ""withdrawn NFT does not have specified ID"")

            // Rather than aborting the transaction if any receiver is absent when we try to pay it,
            // we send the cut to the first valid receiver.
            // The first receiver should therefore either be the seller, or an agreed recipient for
            // any unpaid cuts.
            var residualReceiver: &{FungibleToken.Receiver}? = nil

            // Pay each beneficiary their amount of the payment.
            for cut in self.details.saleCuts {
                if let receiver = cut.receiver.borrow() {
                   let paymentCut <- payment.withdraw(amount: cut.amount)
                    receiver.deposit(from: <-paymentCut)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            assert(residualReceiver != nil, message: ""No valid payment receivers"")

            // At this point, if all recievers were active and availabile, then the payment Vault will have
            // zero tokens left, and this will functionally be a no-op that consumes the empty vault
            residualReceiver!.deposit(from: <-payment)

            // If the listing is purchased, we regard it as completed here.
            // Otherwise we regard it as completed in the destructor.
            emit ListingCompleted(
                listingResourceID: self.uuid,
                storefrontResourceID: self.details.storefrontID,
                purchased: self.details.purchased
            )

            return <-nft
        }

        // destructor
        //
        destroy () {
            // If the listing has not been purchased, we regard it as completed here.
            // Otherwise we regard it as completed in purchase().
            // This is because we destroy the listing in Storefront.removeListing()
            // or Storefront.cleanup() .
            // If we change this destructor, revisit those functions.
            if !self.details.purchased {
                emit ListingCompleted(
                    listingResourceID: self.uuid,
                    storefrontResourceID: self.details.storefrontID,
                    purchased: self.details.purchased
                )
            }
        }

        // initializer
        //
        init (
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut],
            storefrontID: UInt64
        ) {
            // Store the sale information
            self.details = ListingDetails(
                nftType: nftType,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                storefrontID: storefrontID
            )

            // Store the NFT provider
            self.nftProviderCapability = nftProviderCapability

            // Check that the provider contains the NFT.
            // We will check it again when the token is sold.
            // We cannot move this into a function because initializers cannot call member functions.
            let provider = self.nftProviderCapability.borrow()
            assert(provider != nil, message: ""cannot borrow nftProviderCapability"")

            // This will precondition assert if the token is not available.
            let nft = provider!.borrowNFT(id: self.details.nftID)
            assert(nft.isInstance(self.details.nftType), message: ""token is not of specified type"")
            assert(nft.id == self.details.nftID, message: ""token does not have specified ID"")
        }
    }

    // StorefrontManager
    // An interface for adding and removing Listings within a Storefront,
    // intended for use by the Storefront's own
    //
    pub resource interface StorefrontManager {
        // createListing
        // Allows the Storefront owner to create and insert Listings.
        //
        pub fun createListing(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut]
        ): UInt64
        // removeListing
        // Allows the Storefront owner to remove any sale listing, acepted or not.
        //
        pub fun removeListing(listingResourceID: UInt64)
    }

    // StorefrontPublic
    // An interface to allow listing and borrowing Listings, and purchasing items via Listings
    // in a Storefront.
    //
    pub resource interface StorefrontPublic {
        pub fun getListingIDs(): [UInt64]
        pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}?
        pub fun cleanup(listingResourceID: UInt64)
   }

    // Storefront
    // A resource that allows its owner to manage a list of Listings, and anyone to interact with them
    // in order to query their details and purchase the NFTs that they represent.
    //
    pub resource Storefront : StorefrontManager, StorefrontPublic {
        // The dictionary of Listing uuids to Listing resources.
        access(self) var listings: @{UInt64: Listing}

        // insert
        // Create and publish a Listing for an NFT.
        //
         pub fun createListing(
            nftProviderCapability: Capability<&{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>,
            nftType: Type,
            nftID: UInt64,
            salePaymentVaultType: Type,
            saleCuts: [SaleCut]
         ): UInt64 {
            let listing <- create Listing(
                nftProviderCapability: nftProviderCapability,
                nftType: nftType,
                nftID: nftID,
                salePaymentVaultType: salePaymentVaultType,
                saleCuts: saleCuts,
                storefrontID: self.uuid
            )

            let listingResourceID = listing.uuid
            let listingPrice = listing.getDetails().salePrice

            // Add the new listing to the dictionary.
            let oldListing <- self.listings[listingResourceID] <- listing
            // Note that oldListing will always be nil, but we have to handle it.
            destroy oldListing

            emit ListingAvailable(
                storefrontAddress: self.owner?.address!,
                listingResourceID: listingResourceID,
                nftType: nftType,
                nftID: nftID,
                ftVaultType: salePaymentVaultType,
                price: listingPrice
            )

            return listingResourceID
        }

        // removeListing
        // Remove a Listing that has not yet been purchased from the collection and destroy it.
        //
        pub fun removeListing(listingResourceID: UInt64) {
            let listing <- self.listings.remove(key: listingResourceID)
                ?? panic(""missing Listing"")
    
            // This will emit a ListingCompleted event.
            destroy listing
        }

        // getListingIDs
        // Returns an array of the Listing resource IDs that are in the collection
        //
        pub fun getListingIDs(): [UInt64] {
            return self.listings.keys
        }

        // borrowSaleItem
        // Returns a read-only view of the SaleItem for the given listingID if it is contained by this collection.
        //
        pub fun borrowListing(listingResourceID: UInt64): &Listing{ListingPublic}? {
            if self.listings[listingResourceID] != nil {
                return &self.listings[listingResourceID] as! &Listing{ListingPublic}
            } else {
                return nil
            }
        }

        // cleanup
        // Remove an listing *if* it has been purchased.
        // Anyone can call, but at present it only benefits the account owner to do so.
        // Kind purchasers can however call it if they like.
        //
        pub fun cleanup(listingResourceID: UInt64) {
            pre {
                self.listings[listingResourceID] != nil: ""could not find listing with given id""
            }

            let listing <- self.listings.remove(key: listingResourceID)!
            assert(listing.getDetails().purchased == true, message: ""listing is not purchased, only admin can remove"")
            destroy listing
        }

        // destructor
        //
        destroy () {
            destroy self.listings

            // Let event consumers know that this storefront will no longer exist
            emit StorefrontDestroyed(storefrontResourceID: self.uuid)
        }

        // constructor
        //
        init () {
            self.listings <- {}

            // Let event consumers know that this storefront exists
            emit StorefrontInitialized(storefrontResourceID: self.uuid)
        }
    }

    // createStorefront
    // Make creating a Storefront publicly accessible.
    //
    pub fun createStorefront(): @Storefront {
        return <-create Storefront()
    }

    init () {
        self.StorefrontStoragePath = /storage/NFTStorefront
        self.StorefrontPublicPath = /public/NFTStorefront

        emit NFTStorefrontInitialized()
    }
}"
A.0000000000000000.FungibleToken,"/**

# The Flow Fungible Token standard

## `FungibleToken` contract interface

The interface that all fungible token contracts would have to conform to.
If a users wants to deploy a new token contract, their contract
would need to implement the FungibleToken interface.

Their contract would have to follow all the rules and naming
that the interface specifies.

## `Vault` resource

Each account that owns tokens would need to have an instance
of the Vault resource stored in their account storage.

The Vault resource has methods that the owner and other users can call.

## `Provider`, `Receiver`, and `Balance` resource interfaces

These interfaces declare pre-conditions and post-conditions that restrict
the execution of the functions in the Vault.

They are separate because it gives the user the ability to share
a reference to their Vault that only exposes the fields functions
in one or more of the interfaces.

It also gives users the ability to make custom resources that implement
these interfaces to do various things with the tokens.
For example, a faucet can be implemented by conforming
to the Provider interface.

By using resources and interfaces, users of FungibleToken contracts
can send and receive tokens peer-to-peer, without having to interact
with a central ledger smart contract. To send tokens to another user,
a user would simply withdraw the tokens from their Vault, then call
the deposit function on another user's Vault to complete the transfer.

*/

/// FungibleToken
///
/// The interface that fungible token contracts implement.
///
pub contract interface FungibleToken {

    /// The total number of tokens in existence.
    /// It is up to the implementer to ensure that the total supply
    /// stays accurate and up to date
    ///
    pub var totalSupply: UFix64

    /// TokensInitialized
    ///
    /// The event that is emitted when the contract is created
    ///
    pub event TokensInitialized(initialSupply: UFix64)

    /// TokensWithdrawn
    ///
    /// The event that is emitted when tokens are withdrawn from a Vault
    ///
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    /// TokensDeposited
    ///
    /// The event that is emitted when tokens are deposited into a Vault
    ///
    pub event TokensDeposited(amount: UFix64, to: Address?)

    /// Provider
    ///
    /// The interface that enforces the requirements for withdrawing
    /// tokens from the implementing type.
    ///
    /// It does not enforce requirements on `balance` here,
    /// because it leaves open the possibility of creating custom providers
    /// that do not necessarily need their own balance.
    ///
    pub resource interface Provider {

        /// withdraw subtracts tokens from the owner's Vault
        /// and returns a Vault with the removed tokens.
        ///
        /// The function's access level is public, but this is not a problem
        /// because only the owner storing the resource in their account
        /// can initially call this function.
        ///
        /// The owner may grant other accounts access by creating a private
        /// capability that allows specific other users to access
        /// the provider resource through a reference.
        ///
        /// The owner may also grant all accounts access by creating a public
        /// capability that allows all users to access the provider
        /// resource through a reference.
        ///
        pub fun withdraw(amount: UFix64): @Vault {
            post {
                // `result` refers to the return value
                result.balance == amount:
                    ""Withdrawal amount must be the same as the balance of the withdrawn Vault""
            }
        }
    }

    /// Receiver
    ///
    /// The interface that enforces the requirements for depositing
    /// tokens into the implementing type.
    ///
    /// We do not include a condition that checks the balance because
    /// we want to give users the ability to make custom receivers that
    /// can do custom things with the tokens, like split them up and
    /// send them to different places.
    ///
    pub resource interface Receiver {

        /// deposit takes a Vault and deposits it into the implementing resource type
        ///
        pub fun deposit(from: @Vault)
    }

    /// Balance
    ///
    /// The interface that contains the `balance` field of the Vault
    /// and enforces that when new Vaults are created, the balance
    /// is initialized correctly.
    ///
    pub resource interface Balance {

        /// The total balance of a vault
        ///
        pub var balance: UFix64

        init(balance: UFix64) {
            post {
                self.balance == balance:
                    ""Balance must be initialized to the initial balance""
            }
        }
    }

    /// Vault
    ///
    /// The resource that contains the functions to send and receive tokens.
    ///
    pub resource Vault: Provider, Receiver, Balance {

        // The declaration of a concrete type in a contract interface means that
        // every Fungible Token contract that implements the FungibleToken interface
        // must define a concrete `Vault` resource that conforms to the `Provider`, `Receiver`,
        // and `Balance` interfaces, and declares their required fields and functions

        /// The total balance of the vault
        ///
        pub var balance: UFix64

        // The conforming type must declare an initializer
        // that allows prioviding the initial balance of the Vault
        //
        init(balance: UFix64)

        /// withdraw subtracts `amount` from the Vault's balance
        /// and returns a new Vault with the subtracted balance
        ///
        pub fun withdraw(amount: UFix64): @Vault {
            pre {
                self.balance >= amount:
                    ""Amount withdrawn must be less than or equal than the balance of the Vault""
            }
            post {
                // use the special function `before` to get the value of the `balance` field
                // at the beginning of the function execution
                //
                self.balance == before(self.balance) - amount:
                    ""New Vault balance must be the difference of the previous balance and the withdrawn Vault""
            }
        }

        /// deposit takes a Vault and adds its balance to the balance of this Vault
        ///
        pub fun deposit(from: @Vault) {
            // Assert that the concrete type of the deposited vault is the same
            // as the vault that is accepting the deposit
            pre {
                from.isInstance(self.getType()): 
                    ""Cannot deposit an incompatible token type""
            }
            post {
                self.balance == before(self.balance) + before(from.balance):
                    ""New Vault balance must be the sum of the previous balance and the deposited Vault""
            }
        }
    }

    /// createEmptyVault allows any user to create a new Vault that has a zero balance
    ///
    pub fun createEmptyVault(): @Vault {
        post {
            result.balance == 0.0: ""The newly created Vault must have zero balance""
        }
    }
}"
A.0000000000000000.FlowToken,"import FungibleToken from 0x0

pub contract FlowToken: FungibleToken {

    // Total supply of Flow tokens in existence
    pub var totalSupply: UFix64

    // Event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // Event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // Event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // Event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // Event that is emitted when tokens are destroyed
    pub event TokensBurned(amount: UFix64)

    // Event that is emitted when a new minter resource is created
    pub event MinterCreated(allowedAmount: UFix64)

    // Event that is emitted when a new burner resource is created
    pub event BurnerCreated()

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault and governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // holds the balance of a users tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FlowToken.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            FlowToken.totalSupply = FlowToken.totalSupply - self.balance
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @FungibleToken.Vault {
        return <-create Vault(balance: 0.0)
    }

    pub resource Administrator {
        // createNewMinter
        //
        // Function that creates and returns a new minter resource
        //
        pub fun createNewMinter(allowedAmount: UFix64): @Minter {
            emit MinterCreated(allowedAmount: allowedAmount)
            return <-create Minter(allowedAmount: allowedAmount)
        }

        // createNewBurner
        //
        // Function that creates and returns a new burner resource
        //
        pub fun createNewBurner(): @Burner {
            emit BurnerCreated()
            return <-create Burner()
        }
    }

    // Minter
    //
    // Resource object that token admin accounts can hold to mint new tokens.
    //
    pub resource Minter {

        // the amount of tokens that the minter is allowed to mint
        pub var allowedAmount: UFix64

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @FlowToken.Vault {
            pre {
                amount > UFix64(0): ""Amount minted must be greater than zero""
                amount <= self.allowedAmount: ""Amount minted must be less than the allowed amount""
            }
            FlowToken.totalSupply = FlowToken.totalSupply + amount
            self.allowedAmount = self.allowedAmount - amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

        init(allowedAmount: UFix64) {
            self.allowedAmount = allowedAmount
        }
    }

    // Burner
    //
    // Resource object that token admin accounts can hold to burn tokens.
    //
    pub resource Burner {

        // burnTokens
        //
        // Function that destroys a Vault instance, effectively burning the tokens.
        //
        // Note: the burned tokens are automatically subtracted from the
        // total supply in the Vault destructor.
        //
        pub fun burnTokens(from: @FungibleToken.Vault) {
            let vault <- from as! @FlowToken.Vault
            let amount = vault.balance
            destroy vault
            emit TokensBurned(amount: amount)
        }
    }

    init(adminAccount: AuthAccount) {
        self.totalSupply = 0.0

        // Create the Vault with the total supply of tokens and save it in storage
        //
        let vault <- create Vault(balance: self.totalSupply)
        adminAccount.save(<-vault, to: /storage/flowTokenVault)

        // Create a public capability to the stored Vault that only exposes
        // the `deposit` method through the `Receiver` interface
        //
        adminAccount.link<&FlowToken.Vault{FungibleToken.Receiver}>(
            /public/flowTokenReceiver,
            target: /storage/flowTokenVault
        )

        // Create a public capability to the stored Vault that only exposes
        // the `balance` field through the `Balance` interface
        //
        adminAccount.link<&FlowToken.Vault{FungibleToken.Balance}>(
            /public/flowTokenBalance,
            target: /storage/flowTokenVault
        )

        let admin <- create Administrator()
        adminAccount.save(<-admin, to: /storage/flowTokenAdmin)

        // Emit an event that shows that the contract was initialized
        emit TokensInitialized(initialSupply: self.totalSupply)
    }
}"
A.0000000000000000.FUSD,"import FungibleToken from 0x0

pub contract FUSD: FungibleToken {

    // Event that is emitted when the contract is created
    pub event TokensInitialized(initialSupply: UFix64)

    // Event that is emitted when tokens are withdrawn from a Vault
    pub event TokensWithdrawn(amount: UFix64, from: Address?)

    // Event that is emitted when tokens are deposited to a Vault
    pub event TokensDeposited(amount: UFix64, to: Address?)

    // Event that is emitted when new tokens are minted
    pub event TokensMinted(amount: UFix64)

    // The storage path for the admin resource
    pub let AdminStoragePath: StoragePath

    // The storage Path for minters' MinterProxy
    pub let MinterProxyStoragePath: StoragePath

    // The public path for minters' MinterProxy capability
    pub let MinterProxyPublicPath: PublicPath

    // Event that is emitted when a new minter resource is created
    pub event MinterCreated()

    // Total supply of fusd in existence
    pub var totalSupply: UFix64

    // Vault
    //
    // Each user stores an instance of only the Vault in their storage
    // The functions in the Vault are governed by the pre and post conditions
    // in FungibleToken when they are called.
    // The checks happen at runtime whenever a function is called.
    //
    // Resources can only be created in the context of the contract that they
    // are defined in, so there is no way for a malicious user to create Vaults
    // out of thin air. A special Minter resource needs to be defined to mint
    // new tokens.
    //
    pub resource Vault: FungibleToken.Provider, FungibleToken.Receiver, FungibleToken.Balance {

        // holds the balance of a users tokens
        pub var balance: UFix64

        // initialize the balance at resource creation time
        init(balance: UFix64) {
            self.balance = balance
        }

        // withdraw
        //
        // Function that takes an integer amount as an argument
        // and withdraws that amount from the Vault.
        // It creates a new temporary Vault that is used to hold
        // the money that is being transferred. It returns the newly
        // created Vault to the context that called so it can be deposited
        // elsewhere.
        //
        pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
            self.balance = self.balance - amount
            emit TokensWithdrawn(amount: amount, from: self.owner?.address)
            return <-create Vault(balance: amount)
        }

        // deposit
        //
        // Function that takes a Vault object as an argument and adds
        // its balance to the balance of the owners Vault.
        // It is allowed to destroy the sent Vault because the Vault
        // was a temporary holder of the tokens. The Vault's balance has
        // been consumed and therefore can be destroyed.
        pub fun deposit(from: @FungibleToken.Vault) {
            let vault <- from as! @FUSD.Vault
            self.balance = self.balance + vault.balance
            emit TokensDeposited(amount: vault.balance, to: self.owner?.address)
            vault.balance = 0.0
            destroy vault
        }

        destroy() {
            FUSD.totalSupply = FUSD.totalSupply - self.balance
        }
    }

    // createEmptyVault
    //
    // Function that creates a new Vault with a balance of zero
    // and returns it to the calling context. A user must call this function
    // and store the returned Vault in their storage in order to allow their
    // account to be able to receive deposits of this token type.
    //
    pub fun createEmptyVault(): @FUSD.Vault {
        return <-create Vault(balance: 0.0)
    }

    // Minter
    //
    // Resource object that can mint new tokens.
    // The admin stores this and passes it to the minter account as a capability wrapper resource.
    //
    pub resource Minter {

        // mintTokens
        //
        // Function that mints new tokens, adds them to the total supply,
        // and returns them to the calling context.
        //
        pub fun mintTokens(amount: UFix64): @FUSD.Vault {
            pre {
                amount > 0.0: ""Amount minted must be greater than zero""
            }
            FUSD.totalSupply = FUSD.totalSupply + amount
            emit TokensMinted(amount: amount)
            return <-create Vault(balance: amount)
        }

    }

    pub resource interface MinterProxyPublic {
        pub fun setMinterCapability(cap: Capability<&Minter>)
    }

    // MinterProxy
    //
    // Resource object holding a capability that can be used to mint new tokens.
    // The resource that this capability represents can be deleted by the admin
    // in order to unilaterally revoke minting capability if needed.

    pub resource MinterProxy: MinterProxyPublic {

        // access(self) so nobody else can copy the capability and use it.
        access(self) var minterCapability: Capability<&Minter>?

        // Anyone can call this, but only the admin can create Minter capabilities,
        // so the type system constrains this to being called by the admin.
        pub fun setMinterCapability(cap: Capability<&Minter>) {
            self.minterCapability = cap
        }

        pub fun mintTokens(amount: UFix64): @FUSD.Vault {
            return <- self.minterCapability!
            .borrow()!
            .mintTokens(amount:amount)
        }

        init() {
            self.minterCapability = nil
        }

    }

    // createMinterProxy
    //
    // Function that creates a MinterProxy.
    // Anyone can call this, but the MinterProxy cannot mint without a Minter capability,
    // and only the admin can provide that.
    //
    pub fun createMinterProxy(): @MinterProxy {
        return <- create MinterProxy()
    }

    // Administrator
    //
    // A resource that allows new minters to be created
    //
    // We will only want one minter for now, but might need to add or replace them in future.
    // The Minter/Minter Proxy structure enables this.
    // Ideally we would create this structure in a single function, generate the paths from the address
    // and cache all of this information to enable easy revocation but String/Path comversion isn't yet supported.
    //
    pub resource Administrator {

        // createNewMinter
        //
        // Function that creates a Minter resource.
        // This should be stored at a unique path in storage then a capability to it wrapped
        // in a MinterProxy to be stored in a minter account's storage.
        // This is done by the minter account running:
        // transactions/fusd/minter/setup_fusd_minter.cdc
        // then the admin account running:
        // transactions/fusd/admin/deposit_fusd_minter.cdc
        //
        pub fun createNewMinter(): @Minter {
            emit MinterCreated()
            return <- create Minter()
        }

    }

    init() {
        self.AdminStoragePath = /storage/fusdAdmin
        self.MinterProxyPublicPath = /public/fusdMinterProxy
        self.MinterProxyStoragePath = /storage/fusdMinterProxy

        self.totalSupply = 0.0

        let admin <- create Administrator()
        self.account.save(<-admin, to: self.AdminStoragePath)

        // Emit an event that shows that the contract was initialized
        emit TokensInitialized(initialSupply: 0.0)
    }
}"
A.0000000000000000.NonFungibleToken,"/**

## The Flow Non-Fungible Token standard

## `NonFungibleToken` contract interface

The interface that all non-fungible token contracts could conform to.
If a user wants to deploy a new nft contract, their contract would need
to implement the NonFungibleToken interface.

Their contract would have to follow all the rules and naming
that the interface specifies.

## `NFT` resource

The core resource type that represents an NFT in the smart contract.

## `Collection` Resource

The resource that stores a user's NFT collection.
It includes a few functions to allow the owner to easily
move tokens in and out of the collection.

## `Provider` and `Receiver` resource interfaces

These interfaces declare functions with some pre and post conditions
that require the Collection to follow certain naming and behavior standards.

They are separate because it gives the user the ability to share a reference
to their Collection that only exposes the fields and functions in one or more
of the interfaces. It also gives users the ability to make custom resources
that implement these interfaces to do various things with the tokens.

By using resources and interfaces, users of NFT smart contracts can send
and receive tokens peer-to-peer, without having to interact with a central ledger
smart contract.

To send an NFT to another user, a user would simply withdraw the NFT
from their Collection, then call the deposit function on another user's
Collection to complete the transfer.

*/

// The main NFT contract interface. Other NFT contracts will
// import and implement this interface
//
pub contract interface NonFungibleToken {

    // The total number of tokens of this type in existence
    pub var totalSupply: UInt64

    // Event that emitted when the NFT contract is initialized
    //
    pub event ContractInitialized()

    // Event that is emitted when a token is withdrawn,
    // indicating the owner of the collection that it was withdrawn from.
    //
    // If the collection is not in an account's storage, `from` will be `nil`.
    //
    pub event Withdraw(id: UInt64, from: Address?)

    // Event that emitted when a token is deposited to a collection.
    //
    // It indicates the owner of the collection that it was deposited to.
    //
    pub event Deposit(id: UInt64, to: Address?)

    // Interface that the NFTs have to conform to
    //
    pub resource interface INFT {
        // The unique ID that each NFT has
        pub let id: UInt64
    }

    // Requirement that all conforming NFT smart contracts have
    // to define a resource called NFT that conforms to INFT
    pub resource NFT: INFT {
        pub let id: UInt64
    }

    // Interface to mediate withdraws from the Collection
    //
    pub resource interface Provider {
        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NFT {
            post {
                result.id == withdrawID: ""The ID of the withdrawn token must be the same as the requested ID""
            }
        }
    }

    // Interface to mediate deposits to the Collection
    //
    pub resource interface Receiver {

        // deposit takes an NFT as an argument and adds it to the Collection
        //
        pub fun deposit(token: @NFT)
    }

    // Interface that an account would commonly 
    // publish for their collection
    pub resource interface CollectionPublic {
        pub fun deposit(token: @NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NFT
    }

    // Requirement for the the concrete resource type
    // to be declared in the implementing contract
    //
    pub resource Collection: Provider, Receiver, CollectionPublic {

        // Dictionary to hold the NFTs in the Collection
        pub var ownedNFTs: @{UInt64: NFT}

        // withdraw removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NFT

        // deposit takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NFT)

        // getIDs returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64]

        // Returns a borrowed reference to an NFT in the collection
        // so that the caller can read data and call methods from it
        pub fun borrowNFT(id: UInt64): &NFT {
            pre {
                self.ownedNFTs[id] != nil: ""NFT does not exist in the collection!""
            }
        }
    }

    // createEmptyCollection creates an empty Collection
    // and returns it to the caller so that they can own NFTs
    pub fun createEmptyCollection(): @Collection {
        post {
            result.getIDs().length == 0: ""The created collection must be empty!""
        }
    }
}"
A.0000000000000000.ZeedzINO,"import NonFungibleToken from 0x0

/*
    Description: Central Smart Contract for the first generation of Zeedle NFTs

    Zeedles are cute little nature-inspired monsters that grow with the real world weather.
    They are the main characters of Zeedz, the first play-for-purpose game where players 
    reduce global carbon emissions by growing Zeedles. 
    
    This smart contract encompasses the main functionality for the first generation
    of Zeedle NFTs. 

    Oriented much on the standard NFT contract, each Zeedle NFT has a certain typeID,
    which is the type of Zeedle - e.g. ""Baby Aloe Vera"" or ""Ginger Biggy"". A contract-level
    dictionary takes account of the different quentities that have been minted per Zeedle type.

    Different types also imply different rarities, and these are also hardcoded inside 
    the given Zeedle NFT in order to allow the direct querying of the Zeedle's rarity 
    in external applications and wallets.

    Each batch-minting of Zeedles is resembled by an edition number, with the community pre-sale 
    being the first-ever edition (0). This way, each Zeedle can be traced back to the edition it
    was created in, and the number of minted Zeedles of that type in the specific edition.

    Many of the in-game purchases lead to real-world donations to NGOs focused on climate action. 
    The carbonOffset attribute of a Zeedle proves the impact the in-game purchases related to this Zeedle
    have already made with regards to reducing greenhouse gases. This value is computed by taking the 
    current dollar-value of each purchase at the time of the purchase, and applying the dollar-to-CO2-offset
    formular of the current climate action partner. 
*/
pub contract ZeedzINO: NonFungibleToken {

    //  Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, name: String, description: String, typeID: UInt32, serialNumber: String, edition: UInt32, rarity: String)
    pub event Burned(id: UInt64, from: Address?)
    pub event Offset(id: UInt64, amount: UInt64)
    pub event Redeemed(id: UInt64, message: String, from: Address?)

    //  Named Paths
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath
    pub let AdminPrivatePath: PrivatePath

    pub var totalSupply: UInt64

    access(contract) var numberMintedPerType: {UInt32: UInt64}

    pub resource NFT: NonFungibleToken.INFT {
        //  The token's ID
        pub let id: UInt64
        //  The memorable short name for the Zeedle, e.g. “Baby Aloe""
        pub let name: String 
        //  A short description of the Zeedle's type
        pub let description: String 
        //  Number id of the Zeedle type -> e.g ""1 = Ginger Biggy, 2 = Baby Aloe, etc”
        pub let typeID: UInt32
        //  A Zeedle's unique serial number from the Zeedle's edition 
        pub let serialNumber: String
        //  Number id of the Zeedle's edition -> e.g ""1 = first edition, 2 = second edition, etc""  
        pub let edition: UInt32 
        //  The total number of Zeedle's minted in this edition
        pub let editionCap: UInt32 
        //  The Zeedle's evolutionary stage 
        pub let evolutionStage: UInt32
        //  The Zeedle's rarity -> e.g ""RARE, COMMON, LEGENDARY, etc"" 
        pub let rarity: String
        //  URI to the image of the Zeedle 
        pub let imageURI: String
        //  The total amount this Zeedle has contributed to offsetting CO2 emissions
        pub var carbonOffset: UInt64

        init(initID: UInt64, initName: String, initDescription: String, initTypeID: UInt32, initSerialNumber: String, initEdition: UInt32, initEditionCap: UInt32, initEvolutionStage: UInt32, initRarity: String, initImageURI: String) {
            self.id = initID
            self.name = initName
            self.description = initDescription
            self.typeID = initTypeID
            self.serialNumber = initSerialNumber
            self.edition = initEdition
            self.editionCap = initEditionCap
            self.evolutionStage = initEvolutionStage
            self.rarity = initRarity
            self.imageURI = initImageURI
            self.carbonOffset = 0
        }

        pub fun getMetadata(): {String: AnyStruct} {
            return {""name"": self.name, ""description"": self.description, ""typeID"": self.typeID, ""serialNumber"": self.serialNumber, ""edition"": self.edition, ""editionCap"": self.editionCap, ""evolutionStage"": self.evolutionStage, ""rarity"": self.rarity, ""imageURI"": self.imageURI, ""carbonOffset"": self.carbonOffset}
        }

        access(contract) fun increaseOffset(amount: UInt64) {
            self.carbonOffset = self.carbonOffset + amount
        }
    }

    // 
    //  This is the interface that users can cast their Zeedz Collection as
    //  to allow others to deposit Zeedles into their Collection. It also allows for reading
    //  the details of Zeedles in the Collection.
    // 
    pub resource interface ZeedzCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowZeedle(id: UInt64): &ZeedzINO.NFT? {
            post {
                (result == nil) || (result?.id == id):
                    ""Cannot borrow Zeedle reference: The ID of the returned reference is incorrect""
            }
        }
    }

    // 
    //  This is the interface that users can cast their Zeedz Collection as
    //  to allow themselves to call the burn function on their own collection.
    // 
    pub resource interface ZeedzCollectionPrivate {
        pub fun burn(burnID: UInt64)
        pub fun redeem(redeemID: UInt64, message: String)
    }

    //
    //  A collection of Zeedz NFTs owned by an account.
    //   
    pub resource Collection: ZeedzCollectionPublic, ZeedzCollectionPrivate, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {

        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(""Not able to find specified NFT within the owner's collection"")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <-token
        }

        pub fun burn(burnID: UInt64){
            let token <- self.ownedNFTs.remove(key: burnID) ?? panic(""Not able to find specified NFT within the owner's collection"")
            let zeedle <- token as! @ZeedzINO.NFT

            //  reduce numberOfMinterPerType
            ZeedzINO.numberMintedPerType[zeedle.typeID] = ZeedzINO.numberMintedPerType[zeedle.typeID]! - (1 as UInt64)

            destroy zeedle
            emit Burned(id: burnID, from: self.owner?.address)
        }

        pub fun redeem(redeemID: UInt64, message: String){
            let token <- self.ownedNFTs.remove(key: redeemID) ?? panic(""Not able to find specified NFT within the owner's collection"")
            let zeedle <- token as! @ZeedzINO.NFT

            //  reduce numberOfMinterPerType
            ZeedzINO.numberMintedPerType[zeedle.typeID] = ZeedzINO.numberMintedPerType[zeedle.typeID]! - (1 as UInt64)

            destroy zeedle
            emit Redeemed(id: redeemID, message: message, from: self.owner?.address)
        }

        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @ZeedzINO.NFT
            let id: UInt64 = token.id
            //  add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        //
        //  Returns an array of the IDs that are in the collection.
        //
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        //
        //  Gets a reference to an NFT in the collection
        //  so that the caller can read its metadata and call its methods.
        //
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return &self.ownedNFTs[id] as &NonFungibleToken.NFT
        }

        //
        //  Gets a reference to an NFT in the collection as a Zeed,
        //  exposing all of its fields
        //  this is safe as there are no functions that can be called on the Zeed.
        //
        pub fun borrowZeedle(id: UInt64): &ZeedzINO.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
                return ref as! &ZeedzINO.NFT
            } else {
                return nil
            }
        }

        destroy() {
            destroy self.ownedNFTs
        }

        init () {
            self.ownedNFTs <- {}
        }
    }

    //
    //  Public function that anyone can call to create a new empty collection.
    // 
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    //
    //  The Administrator resource that an Administrator or something similar 
    //  would own to be able to mint & level-up NFT's.
    //
    pub resource Administrator {

        //
        //  Mints a new NFT with a new ID
        //  and deposit it in the recipients collection using their collection reference.
        //
        pub fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, name: String, description: String, typeID: UInt32, serialNumber: String, edition: UInt32, editionCap: UInt32, evolutionStage: UInt32, rarity: String, imageURI: String) {
            recipient.deposit(token: <-create ZeedzINO.NFT(initID: ZeedzINO.totalSupply, initName: name, initDescription: description, initTypeID: typeID, initSerialNumber: serialNumber, initEdition: edition, initEdition: editionCap, initEvolutionStage: evolutionStage, initRarity: rarity, initImageURI: imageURI))
            emit Minted(id: ZeedzINO.totalSupply, name: name, description: description, typeID: typeID, serialNumber: serialNumber, edition: edition, rarity: rarity)

            // increase numberOfMinterPerType and totalSupply
            ZeedzINO.totalSupply = ZeedzINO.totalSupply + (1 as UInt64)
            if ZeedzINO.numberMintedPerType[typeID] == nil {
                ZeedzINO.numberMintedPerType[typeID] = 1 
            } else {
                ZeedzINO.numberMintedPerType[typeID] = ZeedzINO.numberMintedPerType[typeID]! + (1 as UInt64)
            }
        }

        //
        //  Increase the Zeedle's total carbon offset by the given amount
        //
        pub fun increaseOffset(zeedleRef: &ZeedzINO.NFT, amount: UInt64) {
            zeedleRef.increaseOffset(amount: amount)
            emit Offset(id: zeedleRef.id, amount: amount)
        }
    }

    //
    //  Get a reference to a Zeedle from an account's Collection, if available.
    //  If an account does not have a Zeedz.Collection, panic.
    //  If it has a collection but does not contain the zeedleId, return nil.
    //  If it has a collection and that collection contains the zeedleId, return a reference to that.
    //
    pub fun fetch(_ from: Address, zeedleID: UInt64): &ZeedzINO.NFT? {
        let collection = getAccount(from)
            .getCapability(ZeedzINO.CollectionPublicPath)!
            .borrow<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic}>()
            ?? panic(""Couldn't get collection"")
        return collection.borrowZeedle(id: zeedleID)
    }

    // 
    //  Returns the number of minted Zeedles for each Zeedle type.
    //
    pub fun getMintedPerType(): {UInt32: UInt64} {
        return self.numberMintedPerType
    }


    init() {
        self.CollectionStoragePath = /storage/ZeedzINOCollection
        self.CollectionPublicPath = /public/ZeedzINOCollection
        self.AdminStoragePath = /storage/ZeedzINOMinter
        self.AdminPrivatePath= /private/ZeedzINOAdminPrivate

        self.totalSupply = 0
        self.numberMintedPerType = {}

        self.account.save(<- create Administrator(), to: self.AdminStoragePath)
        self.account.link<&Administrator>(self.AdminPrivatePath, target: self.AdminStoragePath)

        emit ContractInitialized()
    }
}"
A.0000000000000000.ZeedzDrops,"import FungibleToken from 0x0

pub contract ZeedzDrops {

    pub event ProductPurchased(productID: UInt64, details: ProductDetails, currency: String, userID: String)

    pub event ProductAdded(productID: UInt64, productDetails: ProductDetails)

    pub event ProductsReserved(productID: UInt64, amount: UInt64)

    pub event ProductRemoved(productID: UInt64)

    pub let ZeedzDropsStoragePath: StoragePath

    pub let ZeedzDropsPublicPath: PublicPath

    access(contract) var saleCutRequirements: {String : [SaleCutRequirement]}

    pub struct SaleCutRequirement {
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        pub let ratio: UFix64

        init(receiver: Capability<&{FungibleToken.Receiver}>, ratio: UFix64) {
            pre {
                ratio <= 1.0: ""ratio must be less than or equal to 1.0""
                receiver.borrow() != nil: ""invalid reciever capability""
            }
            self.receiver = receiver
            self.ratio = ratio
        }
    }

    pub struct ProductDetails {
        // product name
        pub let name: String

        // description
        pub let description: String

        // product id
        pub let id: String

        // total product item quantity
        pub let total: UInt64

        // {Type of the FungibleToken => price}
        access(contract) var prices: {String : UFix64}

        // total products sold
        pub var sold: UInt64

        // total products reserved
        pub var reserved: UInt64

        // if true, the product is buyable
        pub var saleEnabled: Bool

        // product sale start timestamp
        pub var timeStart: UFix64

        // product sale start timestamp
        pub var timeEnd: UFix64

        init (
            name: String,
            description: String,
            id: String,
            total: UInt64
            saleEnabled: Bool,
            timeStart: UFix64,
            timeEnd: UFix64,
            prices: {String: UFix64},
        ) {
            self.name = name
            self.description = description
            self.id = id
            self.total = total
            self.sold = 0
            self.reserved = 0
            self.timeStart = timeStart
            self.timeEnd = timeEnd
            self.prices = prices
            self.saleEnabled = saleEnabled
        }

        access(contract) fun setSaleEnabledStatus(status: Bool) {
            self.saleEnabled = status
        }

        access(contract) fun setStartTime(startTime: UFix64) {
            assert(self.timeEnd > startTime, message: ""startTime should be lesser than endTime"")
            self.timeStart = startTime
        }

        access(contract) fun setEndTime(endTime: UFix64) {
            assert(endTime > self.timeStart, message: ""endTime should be grater than startTime"")
            self.timeEnd = endTime
        }

        access(contract) fun setSoldAfterPurchase() {
            self.sold = self.sold + 1
        }

        access(contract) fun reserve(amount: UInt64) {
            self.sold = self.sold + amount
            self.reserved = self.reserved + amount
        }

        access(contract) fun setPrices(prices: {String : UFix64}){
            self.prices = prices
        }

        pub fun getPrices(): {String : UFix64} {
            return self.prices
        }
    }


    pub resource interface ProductPublic {
        pub fun getDetails(): ProductDetails
    }

    pub resource interface ProductsManager {
        pub fun setSaleEnabledStatus(productID: UInt64, status: Bool)
        pub fun setStartTime(productID: UInt64, startTime: UFix64)
        pub fun setEndTime(productID: UInt64, endTime: UFix64)
        pub fun reserve(productID: UInt64, amount: UInt64)
        pub fun removeProduct(productID: UInt64)
        pub fun purchase(productID: UInt64, payment: @FungibleToken.Vault, vaultType: Type, userID: String)
        pub fun purchaseWithDiscount(
            productID: UInt64,
            payment: @FungibleToken.Vault,
            discount: UFix64,
            vaultType: Type,
            userID: String)
        pub fun addProduct(
            name: String, 
            description: String, 
            id: String, 
            total: UInt64, 
            saleEnabled: Bool, 
            timeStart: UFix64, 
            timeEnd: UFix64, 
            prices: {String : UFix64}): UInt64
        pub fun setPrices(productID: UInt64, prices: {String : UFix64})
    }

    pub resource interface DropsManager {
        pub fun updateSaleCutRequirement(requirements: [SaleCutRequirement], vaultType: Type)
    }

    pub resource interface DropsPublic {
        pub fun getProductIDs(): [UInt64]
        pub fun borrowProduct(id: UInt64): &Product?
    }

    pub resource Product: ProductPublic {
  
        access(contract) let details: ProductDetails

        pub fun getDetails(): ProductDetails {
            return self.details
        }

        access(contract) fun purchase(payment: @FungibleToken.Vault, vaultType: Type, userID: String) {
            pre {
                self.details.saleEnabled == true: ""the sale of this product is disabled""
                (self.details.total - self.details.sold) > 0: ""these products are sold out""
                payment.isInstance(vaultType): ""payment vault is not requested fungible token type""
                payment.balance == self.details.prices[vaultType.identifier]: ""payment vault does not contain requested price""
                getCurrentBlock().timestamp > self.details.timeStart: ""the sale of this product has not started yet""
                getCurrentBlock().timestamp < self.details.timeEnd: ""the sale of this product has ended""
                ZeedzDrops.saleCutRequirements[vaultType.identifier] != nil: ""sale cuts not set for requested fungible token""
            }

            var residualReceiver: &{FungibleToken.Receiver}? = nil

            for cut in ZeedzDrops.saleCutRequirements[vaultType.identifier]! {
                if let receiver = cut.receiver.borrow() {
                   let paymentCut <- payment.withdraw(amount: cut.ratio * self.details.prices[vaultType.identifier]!)
                    receiver.deposit(from: <-paymentCut)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            assert(residualReceiver != nil, message: ""no valid payment receivers"")

            residualReceiver!.deposit(from: <-payment)

            self.details.setSoldAfterPurchase()

            emit ProductPurchased(productID: self.uuid, details: self.details, currency: vaultType.identifier, userID: userID)
        }

        access(contract) fun purchaseWithDiscount(payment: @FungibleToken.Vault, discount: UFix64, productID: UInt64, vaultType: Type, userID: String) {
             pre {
                discount < 1.0: ""discount cannot be higher than 100%""
                self.details.saleEnabled == true: ""the sale of this product is disabled""
                (self.details.total - self.details.sold) > 0: ""these products are sold out""
                payment.isInstance(vaultType): ""payment vault is not requested fungible token type""
                (payment.balance) == self.details.prices[vaultType.identifier]!*(1.0-discount): ""payment vault does not contain requested price""
                getCurrentBlock().timestamp > self.details.timeStart: ""the sale of this product has not started yet""
                getCurrentBlock().timestamp < self.details.timeEnd: ""the sale of this product has ended""
                ZeedzDrops.saleCutRequirements[vaultType.identifier] != nil: ""sale cuts not set for requested fungible token""
            }

            var residualReceiver: &{FungibleToken.Receiver}? = nil

            for cut in ZeedzDrops.saleCutRequirements[vaultType.identifier]! {
                if let receiver = cut.receiver.borrow() {
                   let paymentCut <- payment.withdraw(amount: cut.ratio * self.details.prices[vaultType.identifier]!*(1.0-discount))
                    receiver.deposit(from: <-paymentCut)
                    if (residualReceiver == nil) {
                        residualReceiver = receiver
                    }
                }
            }

            assert(residualReceiver != nil, message: ""no valid payment receivers"")

            residualReceiver!.deposit(from: <-payment)

            self.details.setSoldAfterPurchase()

            emit ProductPurchased(productID: self.uuid, details: self.details, currency: vaultType.identifier, userID: userID)
        }

        destroy () {
            emit ProductRemoved(
                productID: self.uuid,
            )
        }

        init (
            name: String, 
            description: String, 
            id: String, 
            total: UInt64, 
            saleEnabled: Bool, 
            timeStart: UFix64, 
            timeEnd: UFix64, 
            prices: {String : UFix64}) {
            self.details = ProductDetails(
                name: name, 
                description: description, 
                id: id, 
                total: total, 
                saleEnabled: saleEnabled, 
                timeStart: timeStart, 
                timeEnd: timeEnd, 
                prices: prices
                )
        }
    }

    pub resource DropsAdmin: ProductsManager, DropsManager, DropsPublic {
        pub fun addProduct(
            name: String, 
            description: String, 
            id: String, 
            total: UInt64, 
            saleEnabled: Bool, 
            timeStart: UFix64, 
            timeEnd: UFix64, 
            prices: {String : UFix64}
            ): UInt64 {
            let product <- create Product(
                        name: name, 
                        description: description, 
                        id: id,
                        total: total,
                        saleEnabled: saleEnabled,
                        timeStart: timeStart,
                        timeEnd: timeEnd,
                        prices: prices
                    )

            let productID = product.uuid

            let details = product.getDetails()
            
            let oldProduct <- self.products[productID] <- product
            // Note that oldProduct will always be nil, but we have to handle it.
            destroy oldProduct

            emit ProductAdded(
                productID: productID,
                productDetails: details
            )

            return productID
        }

        access(contract) var products: @{UInt64: Product}

        pub fun reserve(productID: UInt64, amount: UInt64) {
            let product = self.borrowProduct(id: productID) ?? panic(""not able to borrow specified product"")
            assert(product.details.total - product.details.sold >= amount, message: ""reserve amount can't be higher than available pack amount"")
            product.details.reserve(amount: amount)
            emit ProductsReserved(productID: productID, amount: amount)

        }
        pub fun removeProduct(productID: UInt64) {
            pre {
                self.products[productID] != nil: ""could not find product with given id""
            }
            let product <- self.products.remove(key: productID)!
            destroy product
        }

        pub fun setSaleEnabledStatus(productID: UInt64, status: Bool) {
            let product = self.borrowProduct(id: productID) ?? panic(""not able to borrow specified product"")
            product.details.setSaleEnabledStatus(status: status)
        }

        pub fun setStartTime(productID: UInt64, startTime: UFix64,) {
            let product = self.borrowProduct(id :productID) ?? panic(""not able to borrow specified product"")
            product.details.setStartTime(startTime: startTime)
        }

        pub fun setEndTime(productID: UInt64, endTime: UFix64) {
            let product = self.borrowProduct(id :productID) ?? panic(""not able to borrow specified product"")
            product.details.setEndTime(endTime: endTime)
        }

        pub fun purchase(productID: UInt64, payment: @FungibleToken.Vault, vaultType: Type, userID: String) {
            let product = self.borrowProduct(id: productID) ?? panic(""not able to borrow specified product"")
            product.purchase(payment: <- payment, vaultType: vaultType, userID: userID)
        }

        pub fun purchaseWithDiscount(productID: UInt64, payment: @FungibleToken.Vault, discount: UFix64, vaultType: Type, userID: String) {
            let product = self.borrowProduct(id: productID) ?? panic(""not able to borrow specified product"")
            product.purchaseWithDiscount(payment: <- payment, discount: discount, productID: productID, vaultType: vaultType, userID: userID)
        }

        pub fun updateSaleCutRequirement(requirements: [SaleCutRequirement], vaultType: Type) {
            var totalRatio: UFix64 = 0.0
            for requirement in requirements {
                totalRatio = totalRatio + requirement.ratio
            }
            assert(totalRatio <= 1.0, message: ""total ratio must be less than or equal to 1.0"")
            ZeedzDrops.saleCutRequirements[vaultType.identifier] = requirements
        }

        pub fun setPrices(productID: UInt64, prices: {String : UFix64}) {
            let product = self.borrowProduct(id: productID) ?? panic(""not able to borrow specified product"")
            product.details.setPrices(prices: prices)
        }

        pub fun getProductIDs(): [UInt64] {
            return self.products.keys
        }

        pub fun borrowProduct(id: UInt64): &Product? {
            if self.products[id] != nil {
                return &self.products[id] as! &Product
            } else {
                return nil
            }
        }

        init(){
             self.products <- {}
        }
        destroy () {
            destroy self.products
        }
    }

    pub fun getAllSaleCutRequirements(): {String: [SaleCutRequirement]} {
        return self.saleCutRequirements
    }

    pub fun getAllProductIDs(): [UInt64] {
        let drops = self.account.getCapability<&ZeedzDrops.DropsAdmin{ZeedzDrops.DropsPublic}>(ZeedzDrops.ZeedzDropsPublicPath)
            .borrow() 
            ?? panic(""Could not borrow public drops capability"")
        return drops.getProductIDs()
    }

    pub fun getProduct(id: UInt64): &Product? {
        let drops = self.account.getCapability<&ZeedzDrops.DropsAdmin{ZeedzDrops.DropsPublic}>(ZeedzDrops.ZeedzDropsPublicPath)
            .borrow() 
            ?? panic(""Could not borrow public drops capability"")
        return drops.borrowProduct(id: id)
    }

    init () {
        self.ZeedzDropsStoragePath = /storage/ZeedzDrops
        self.ZeedzDropsPublicPath= /public/ZeedzDrops
        self.saleCutRequirements = {}

        let admin <- create DropsAdmin()
        self.account.save(<-admin, to: self.ZeedzDropsStoragePath)
        self.account.link<&ZeedzDrops.DropsAdmin{ZeedzDrops.DropsPublic}>(self.ZeedzDropsPublicPath, target: self.ZeedzDropsStoragePath)
    }
}"
A.0000000000000000.ZeedzItems,"import NonFungibleToken from 0x0

/*
    Description: Central Smart Contract for arbitrary ZeedzItems

    The main heros of Zeedz are Zeedles - cute little nature-inspired monsters that grow 
    with the real world weather. But there are manifold items that users can pick up
    along their journey, from Early Access keys to Zeedle wearables. These items are
    so called ZeedzItems. 
    
    This smart contract encompasses the main functionality for ZeedzItems. Since the main 
    functionality lies in their plain ownership, their design is held intentionally simple. 
    A single typeID denominates their specific type, and additional metadata can be passed
    along into a flexible {String: String} dictionary. 
*/
pub contract ZeedzItems: NonFungibleToken {

    // Events
    pub event ContractInitialized()
    pub event Withdraw(id: UInt64, from: Address?)
    pub event Deposit(id: UInt64, to: Address?)
    pub event Minted(id: UInt64, metadata: {String: String})
    pub event Burned(id: UInt64, from: Address?)

    // Named Paths
    pub let CollectionStoragePath: StoragePath
    pub let CollectionPublicPath: PublicPath
    pub let AdminStoragePath: StoragePath
    pub let AdminPrivatePath: PrivatePath

    // totalSupply
    // The total number of ZeedzItems that have been minted
    pub var totalSupply: UInt64

    // 
    // A ZeedzItem as an NFT
    //
    pub resource NFT: NonFungibleToken.INFT {
        // The token's ID
        pub let id: UInt64
        // The items's type, e.g. 1 == early Acess Alpha Key
        pub let typeID: UInt64
        // String mapping to hold metadata
        access(self) let metadata: {String: String}

        // initializer
        init(initID: UInt64, initTypeID: UInt64, initMetadata: {String : String}) {
            self.id = initID
            self.typeID = initTypeID
            self.metadata = initMetadata
        }

        pub fun getMetadata(): {String: String}{
            return self.metadata
        }

    }

    //
    // This is the interface that users can cast their ZeedzItems Collection as
    // to allow others to deposit ZeedzItems into their Collection. It also allows for reading
    // the details of ZeedzItems in the Collection.
    //
    pub resource interface ZeedzItemsCollectionPublic {
        pub fun deposit(token: @NonFungibleToken.NFT)
        pub fun getIDs(): [UInt64]
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT
        pub fun borrowZeedzItem(id: UInt64): &ZeedzItems.NFT? {
            // If the result isn't nil, the id of the returned reference
            // should be the same as the argument to the function
            post {
                (result == nil) || (result?.id == id):
                    ""Cannot borrow ZeedzItem reference: The ID of the returned reference is incorrect""
            }
        }
    }

    // 
    // This is the interface that users can cast their ZeedzItems Collection as
    // to allow themselves to call the burn function on their own collection.
    // 
    pub resource interface ZeedzItemsCollectionPrivate {
        pub fun burn(burnID: UInt64)
    }

    // 
    // A collection of ZeedzItem NFTs owned by an account
    //
    pub resource Collection: ZeedzItemsCollectionPublic, ZeedzItemsCollectionPrivate, NonFungibleToken.Provider, NonFungibleToken.Receiver, NonFungibleToken.CollectionPublic {
        // dictionary of NFT conforming tokens
        // NFT is a resource type with an `UInt64` ID field
        pub var ownedNFTs: @{UInt64: NonFungibleToken.NFT}

        // withdraw
        // Removes an NFT from the collection and moves it to the caller
        pub fun withdraw(withdrawID: UInt64): @NonFungibleToken.NFT {
            let token <- self.ownedNFTs.remove(key: withdrawID) ?? panic(""Not able to find specified NFT within the owner's collection"")
            emit Withdraw(id: token.id, from: self.owner?.address)
            return <-token
        }

        pub fun burn(burnID: UInt64){
             let token <- self.ownedNFTs.remove(key: burnID) ?? panic(""Not able to find specified NFT within the owner's collection"")
             destroy token
             emit Burned(id: burnID, from: self.owner?.address)
        }

        // deposit
        // Takes a NFT and adds it to the collections dictionary
        // and adds the ID to the id array
        pub fun deposit(token: @NonFungibleToken.NFT) {
            let token <- token as! @ZeedzItems.NFT
            let id: UInt64 = token.id
            // add the new token to the dictionary which removes the old one
            let oldToken <- self.ownedNFTs[id] <- token
            emit Deposit(id: id, to: self.owner?.address)
            destroy oldToken
        }

        // getIDs
        // Returns an array of the IDs that are in the collection
        pub fun getIDs(): [UInt64] {
            return self.ownedNFTs.keys
        }

        // borrowNFT
        // Gets a reference to an NFT in the collection
        // so that the caller can read its metadata and call its methods
        pub fun borrowNFT(id: UInt64): &NonFungibleToken.NFT {
            return &self.ownedNFTs[id] as &NonFungibleToken.NFT
        }

        // borrowZeedzItem
        // Gets a reference to an NFT in the collection as a ZeedzItem,
        // exposing all of its fields (including the typeID).
        // This is safe as there are no functions that can be called on the ZeedzItem.
        pub fun borrowZeedzItem(id: UInt64): &ZeedzItems.NFT? {
            if self.ownedNFTs[id] != nil {
                let ref = &self.ownedNFTs[id] as auth &NonFungibleToken.NFT
                return ref as! &ZeedzItems.NFT
            } else {
                return nil
            }
        }

        // destructor
        destroy() {
            destroy self.ownedNFTs
        }

        // initializer
        init () {
            self.ownedNFTs <- {}
        }
    }

    //
    // A public function that anyone can call to create a new empty collection
    //
    pub fun createEmptyCollection(): @NonFungibleToken.Collection {
        return <- create Collection()
    }

    //
    // Resource that an admin or something similar would own to be
    // able to mint new NFTs
    //
    pub resource Administrator {

        // 
        // Mints a new NFT with a new ID
        // and deposit it in the recipients collection using their collection reference
        //
        pub fun mintNFT(recipient: &{NonFungibleToken.CollectionPublic}, typeID: UInt64, metadata: {String : String}) {
            emit Minted(id: ZeedzItems.totalSupply, metadata: metadata)
            // deposit it in the recipient's account using their reference
            recipient.deposit(token: <-create ZeedzItems.NFT(initID: ZeedzItems.totalSupply, initTypeID: typeID, metadata: metadata))
            ZeedzItems.totalSupply = ZeedzItems.totalSupply + (1 as UInt64)
        }
    }

    // 
    // Get a reference to a ZeedzItem from an account's Collection, if available.
    // If an account does not have a ZeedzItems.Collection, panic.
    // If it has a collection but does not contain the itemId, return nil.
    // If it has a collection and that collection contains the itemId, return a reference to that.
    //
    pub fun fetch(_ from: Address, itemID: UInt64): &ZeedzItems.NFT? {
        let collection = getAccount(from)
            .getCapability(ZeedzItems.CollectionPublicPath)!
            .borrow<&ZeedzItems.Collection{ZeedzItems.ZeedzItemsCollectionPublic}>()
            ?? panic(""Couldn't get collection"")
        // We trust ZeedzItems.Collection.borowZeedzItem to get the correct itemID
        // (it checks it before returning it).
        return collection.borrowZeedzItem(id: itemID)
    }


    init() {
        // Set our named paths
        self.CollectionStoragePath = /storage/ZeedzItemsCollection
        self.CollectionPublicPath = /public/ZeedzItemsCollection
        self.AdminStoragePath = /storage/ZeedzItemsMinter
        self.AdminPrivatePath=/private/ZeedzItemsAdminPrivate

        // Initialize the total supply
        self.totalSupply = 0

        // Create a Admin resource and save it to storage
        self.account.save(<- create Administrator(), to: self.AdminStoragePath)
        self.account.link<&Administrator>(self.AdminPrivatePath, target: self.AdminStoragePath)

        emit ContractInitialized()
    }
}"
A.0000000000000000.ZeedzSettings,"pub contract ZeedzSettings {

    pub let ZeedzSettingsAdminStoragePath: StoragePath

    // Setting name => AnyStruct
    access(contract) var settings: {String: AnyStruct}

    //
    // Administrator resource, owner account can update the Zeedz settings.
    //
    pub resource Administrator {
        pub fun updateSettings(_ settings: {String: AnyStruct}) {
            ZeedzSettings.settings = settings
        }
    }

    //
    // Returns all of the current Zeedz settings
    //
    pub fun getAllSettings(): {String: AnyStruct} {
        return self.settings
    }

    init () {
        self.ZeedzSettingsAdminStoragePath = /storage/ZeedzSettingsAdmin

        self.settings = {}

        let admin <- create Administrator()
        self.account.save(<-admin, to: self.ZeedzSettingsAdminStoragePath)
    }
}"
A.0000000000000000.TokenForwarding,"/**

# Fungible Token Forwarding Contract

This contract shows how an account could set up a custom FungibleToken Receiver
to allow them to forward tokens to a different account whenever they receive tokens.

They can publish this Forwarder resource as a Receiver capability just like a Vault,
and the sender doesn't even need to know it is different.

When an account wants to create a Forwarder, they call the createNewForwarder
function and provide it with the Receiver reference that they want to forward
their tokens to.

*/

import NonFungibleToken from 0x0

pub contract TokenForwarding {

    // Event that is emitted when tokens are deposited to the target receiver
    pub event ForwardedDeposit(amount: UFix64, from: Address?)

    pub resource Forwarder: FungibleToken.Receiver {

        // This is where the deposited tokens will be sent.
        // The type indicates that it is a reference to a receiver
        //
        access(self) var recipient: Capability

        // deposit
        //
        // Function that takes a Vault object as an argument and forwards
        // it to the recipient's Vault using the stored reference
        //
        pub fun deposit(from: @FungibleToken.Vault) {
            let receiverRef = self.recipient.borrow<&{FungibleToken.Receiver}>()!

            let balance = from.balance

            receiverRef.deposit(from: <-from)

            emit ForwardedDeposit(amount: balance, from: self.owner?.address)
        }

        // changeRecipient changes the recipient of the forwarder to the provided recipient
        //
        pub fun changeRecipient(_ newRecipient: Capability) {
            pre {
                newRecipient.borrow<&{FungibleToken.Receiver}>() != nil: ""Could not borrow Receiver reference from the Capability""
            }
            self.recipient = newRecipient
        }

        init(recipient: Capability) {
            pre {
                recipient.borrow<&{FungibleToken.Receiver}>() != nil: ""Could not borrow Receiver reference from the Capability""
            }
            self.recipient = recipient
        }
    }

    // createNewForwarder creates a new Forwarder reference with the provided recipient
    //
    pub fun createNewForwarder(recipient: Capability): @Forwarder {
        return <-create Forwarder(recipient: recipient)
    }
}"
A.0000000000000000.OnChainMultiSig,"import Crypto
import FungibleToken from 0x0

pub contract OnChainMultiSig {
    
    
    // ------- Events ------- 
    pub event NewPayloadAdded(resourceId: UInt64, txIndex: UInt64);
    pub event NewPayloadSigAdded(resourceId: UInt64, txIndex: UInt64);

    
    // ------- Interfaces ------- 
    pub resource interface PublicSigner {
        pub fun addNewPayload(payload: @PayloadDetails, publicKey: String, sig: [UInt8]);
        pub fun addPayloadSignature (txIndex: UInt64, publicKey: String, sig: [UInt8]);
        pub fun executeTx(txIndex: UInt64): @AnyResource?;
        pub fun UUID(): UInt64;
        pub fun getTxIndex(): UInt64;
        pub fun getSignerKeys(): [String];
        pub fun getSignerKeyAttr(publicKey: String): PubKeyAttr?;
    }
    
    
    pub resource interface KeyManager {
        pub fun addKeys( multiSigPubKeys: [String], multiSigKeyWeights: [UFix64], multiSigAlgos: [UInt8]);
        pub fun removeKeys( multiSigPubKeys: [String]);
    }
    

    pub resource interface SignatureManager {
        pub fun getSignerKeys(): [String];
        pub fun getSignerKeyAttr(publicKey: String): PubKeyAttr?;
        pub fun addNewPayload (resourceId: UInt64, payload: @PayloadDetails, publicKey: String, sig: [UInt8]);
        pub fun addPayloadSignature (resourceId: UInt64, txIndex: UInt64, publicKey: String, sig: [UInt8]);
        pub fun readyForExecution(txIndex: UInt64): @PayloadDetails?;
        pub fun configureKeys (pks: [String], kws: [UFix64], sa: [UInt8]);
        pub fun removeKeys (pks: [String]);
    }
    
    // ------- Structs -------
    pub struct PubKeyAttr {
        pub let sigAlgo: UInt8;
        pub let weight: UFix64
        
        init(sa: UInt8, w: UFix64) {
            self.sigAlgo = sa;
            self.weight = w;
        }
    }

    
    // ------- Resources ------- 
    pub resource PayloadDetails {
        pub var txIndex: UInt64;
        pub var method: String;
        pub(set) var rsc: @AnyResource?;
        access(self) let args: [AnyStruct];
        
        access(contract) let signatures: [[UInt8]];
        access(contract) let pubKeys: [String];
        
        pub fun getArg(i: UInt): AnyStruct? {
            return self.args[i]
        }      

        // Calculate the bytes of a payload
        pub fun getSignableData(): [UInt8] {
            var s = self.txIndex.toBigEndianBytes();
            s = s.concat(self.method.utf8);
            var i: Int = 0;
            while i < self.args.length {
                let a = self.args[i];
                var b: [UInt8] = [];
                let t = a.getType();
                switch t {
                    case Type<String>():
                        let temp = a as? String;
                        b = temp!.utf8; 
                    case Type<UInt64>():
                        let temp = a as? UInt64;
                        b = temp!.toBigEndianBytes(); 
                    case Type<UFix64>():
                        let temp = a as? UFix64;
                        b = temp!.toBigEndianBytes(); 
                    case Type<UInt8>():
                        let temp = a as? UInt8;
                        b = temp!.toBigEndianBytes();
                    case Type<Address>():
                        let temp = a as? Address;
                        b = temp!.toBytes();
                    case Type<Path>():
                        b = ""Path:"".concat(i.toString()).utf8;
                    case Type<StoragePath>():
                        b = ""StoragePath:"".concat(i.toString()).utf8;
                    case Type<PrivatePath>():
                        b = ""PrivatePath:"".concat(i.toString()).utf8;
                    case Type<PublicPath>():
                        b = ""PublicPath:"".concat(i.toString()).utf8;
                    default:
                        panic (""Payload arg type not supported"")
                }
                s = s.concat(b);
                i = i + 1
            }
            return s; 
        }
        
        // Verify the signature and return the total weight of valid signatures, if any.
        pub fun verifySigners (pks: [String], sigs: [[UInt8]], currentKeyList: {String: PubKeyAttr}): UFix64? {
            assert(pks.length == sigs.length, message: ""Cannot verify signatures without corresponding public keys"");
            
            var totalAuthorizedWeight: UFix64 = 0.0;
            var keyList = Crypto.KeyList();
            let keyListSignatures: [Crypto.KeyListSignature] = []
            var payloadInBytes: [UInt8] = self.getSignableData();

            // index of the public keys and signature list
            var i = 0;
            var keyIndex = 0;
            while (i < pks.length) {
                // check if the public key is a registered signer
                if (currentKeyList[pks[i]] == nil){
                    i = i + 1;
                    continue;
                }

                let pk = PublicKey(
                    publicKey: pks[i].decodeHex(),
                    signatureAlgorithm: SignatureAlgorithm(rawValue: currentKeyList[pks[i]]!.sigAlgo) ?? panic (""Invalid signature algo"")
                )
                
                let keyListSig = Crypto.KeyListSignature(keyIndex: keyIndex, signature: sigs[i]);
                keyListSignatures.append(keyListSig);

                keyList.add(
                    pk, 
                    hashAlgorithm: HashAlgorithm.SHA3_256,
                    weight: currentKeyList[pks[i]]!.weight
                )
                totalAuthorizedWeight = totalAuthorizedWeight + currentKeyList[pks[i]]!.weight
                i = i + 1;
                keyIndex = keyIndex + 1;
            }
            
            let isValid = keyList.verify(
                signatureSet: keyListSignatures,
                signedData: payloadInBytes,
            )
            if (isValid) {
                return totalAuthorizedWeight
            } else {
                return nil
            }
        }
        
        pub fun addSignature(sig: [UInt8], publicKey: String){
            self.signatures.append(sig);
            self.pubKeys.append(publicKey);
        }
        
        destroy () {
            destroy self.rsc
        }

        init(txIndex: UInt64, method: String, args: [AnyStruct], rsc: @AnyResource?) {
            self.args = args;
            self.txIndex = txIndex;
            self.method = method;
            self.signatures= []
            self.pubKeys = []
            
            let r: @AnyResource <- rsc ?? nil
            if r != nil && r.isInstance(Type<@FungibleToken.Vault>()) {
                let vault <- r as! @FungibleToken.Vault
                assert(vault.balance == args[0] as! UFix64, message: ""First argument must be balance of Vault"")
                self.rsc <- vault;
            } else {
                self.rsc <- r;
            }
        }
    }
    
    pub resource Manager: SignatureManager {
        
        // Sequential identifier for each stored tx payload.
        pub var txIndex: UInt64;
        // Map of {publicKey: PubKeyAttr}
        access(self) let keyList: {String: PubKeyAttr};
        // Map of {txIndex: PayloadDetails}
        access(self) let payloads: @{UInt64: PayloadDetails}

        pub fun getSignerKeys(): [String] {
            return self.keyList.keys
        }

        pub fun getSignerKeyAttr(publicKey: String): PubKeyAttr? {
            return self.keyList[publicKey]
        }
        
        pub fun removePayload(txIndex: UInt64): @PayloadDetails {
            assert(self.payloads.containsKey(txIndex), message: ""no payload at txIndex"")
            return <- self.payloads.remove(key: txIndex)!
        }
        
        pub fun configureKeys (pks: [String], kws: [UFix64], sa: [UInt8]) {
            var i: Int =  0;
            while (i < pks.length) {
                let a = PubKeyAttr(sa: sa[i], w: kws[i])
                self.keyList.insert(key: pks[i], a)
                i = i + 1;
            }
        }

        pub fun removeKeys (pks: [String]) {
            var i: Int =  0;
            while (i < pks.length) {
                self.keyList.remove(key:pks[i])
                i = i + 1;
            }
        }
        
        pub fun addNewPayload (resourceId: UInt64, payload: @PayloadDetails, publicKey: String, sig: [UInt8]) {

            // Reject the tx if the provided key is not in the keyList
            assert(self.keyList.containsKey(publicKey), message: ""Public key is not a registered signer"");

            // Ensure the signed txIndex is the next txIndex for this resource
            let txIndex = self.txIndex + (1 as UInt64);
            assert(payload.txIndex == txIndex, message: ""Incorrect txIndex provided in payload"")
            assert(!self.payloads.containsKey(txIndex), message: ""Payload index already exist"");
            self.txIndex = txIndex;

            // Check if the payloadSig is signed by one of the keys in `keyList`, preventing others from adding to storage
            // if approvalWeight is nil, the public key is not in the `keyList` or cannot be verified
            let approvalWeight = payload.verifySigners(pks: [publicKey], sigs: [sig], currentKeyList: self.keyList)
            if ( approvalWeight == nil) {
                panic (""Invalid signer"")
            }
            
            // Insert the payload and the first signature into the resource maps
            payload.addSignature(sig: sig, publicKey: publicKey)
            self.payloads[txIndex] <-! payload;

            emit NewPayloadAdded(resourceId: resourceId, txIndex: txIndex)
        }

        pub fun addPayloadSignature (resourceId: UInt64, txIndex: UInt64, publicKey: String, sig: [UInt8]) {
            assert(self.payloads.containsKey(txIndex), message: ""Payload has not been added"");
            assert(self.keyList.containsKey(publicKey), message: ""Public key is not a registered signer"");

            let p <- self.payloads.remove(key: txIndex)!;
            let currentIndex = p.signatures.length
            var i = 0;
            while i < currentIndex {
                if p.pubKeys[i] == publicKey {
                    break
                }
                i = i + 1;
            } 
            if i < currentIndex {
                self.payloads[txIndex] <-! p;
                panic (""Signature already added for this txIndex"")
            } else {
                let approvalWeight = p.verifySigners( pks: [publicKey], sigs: [sig], currentKeyList: self.keyList)
                if ( approvalWeight == nil) {
                    self.payloads[txIndex] <-! p;
                    panic (""Invalid signer"")
                } else {
                    p.addSignature(sig: sig, publicKey: publicKey)
                    self.payloads[txIndex] <-! p;

                    emit NewPayloadSigAdded(resourceId: resourceId, txIndex: txIndex)
                }
            }

        }

        // Ensure the total weights of the tx signers is sufficient to execute the tx
        pub fun readyForExecution(txIndex: UInt64): @PayloadDetails? {
            assert(self.payloads.containsKey(txIndex), message: ""No payload for such index"");
            let p <- self.payloads.remove(key: txIndex)!;
            let approvalWeight = p.verifySigners( pks: p.pubKeys, sigs: p.signatures, currentKeyList: self.keyList)
            if (approvalWeight! >= 1000.0) {
                return <- p
            } else {
                self.payloads[txIndex] <-! p;
                return nil
            }
        }

        destroy () {
            destroy self.payloads
        }
        
        init(publicKeys: [String], pubKeyAttrs: [PubKeyAttr]){
            assert( publicKeys.length == pubKeyAttrs.length, message: ""Public keys must have associated attributes"")
            self.payloads <- {};
            self.keyList = {};
            self.txIndex = 0;
            
            var i: Int = 0;
            while (i < publicKeys.length){
                self.keyList.insert(key: publicKeys[i], pubKeyAttrs[i]);
                i = i + 1;
            }
        }
    }
        
    pub fun createMultiSigManager(publicKeys: [String], pubKeyAttrs: [PubKeyAttr]): @Manager {
        return <- create Manager(publicKeys: publicKeys, pubKeyAttrs: pubKeyAttrs)
    }

    pub fun createPayload(txIndex: UInt64, method: String, args: [AnyStruct], rsc: @AnyResource?): @PayloadDetails{
        return <- create PayloadDetails(txIndex: txIndex, method: method, args: args, rsc: <-rsc)
    }
}"
A.0000000000000000.ZeedzMarketplace,"import FungibleToken from 0x0
import NFTStorefront from 0x0

pub contract ZeedzMarketplace {

    pub event AddedListing(
        storefrontAddress: Address,
        listingResourceID: UInt64,
        nftType: Type,
        nftID: UInt64,
        ftVaultType: Type,
        price: UFix64
    )

    pub event RemovedListing(
        listingResourceID: UInt64,
        nftType: Type,
        nftID: UInt64,
        ftVaultType: Type,
        price: UFix64
    )

    //
    // A NFT listed on the Zeedz Marketplace, contains the NFTStorefront listingID, capability, listingDetails and timestamp.
    //
    pub struct Item {
        pub let storefrontPublicCapability: Capability<&{NFTStorefront.StorefrontPublic}>

        // NFTStorefront.Listing resource uuid
        pub let listingID: UInt64

        // Store listingDetails to prevent vanishing from storefrontPublicCapability
        pub let listingDetails: NFTStorefront.ListingDetails

        // Time when the listing was added to the Zeedz Marketplace
        pub let timestamp: UFix64

        init(storefrontPublicCapability: Capability<&{NFTStorefront.StorefrontPublic}>, listingID: UInt64) {
            self.storefrontPublicCapability = storefrontPublicCapability
            self.listingID = listingID
            let storefrontPublic = storefrontPublicCapability.borrow() ?? panic(""Could not borrow public storefront from capability"")
            let listingPublic = storefrontPublic.borrowListing(listingResourceID: listingID) ?? panic(""no listing id"")
            // check if owner is correct
            assert(listingPublic.borrowNFT() != nil, message: ""could not borrow NFT"")

            self.listingDetails = listingPublic.getDetails()
            self.timestamp = getCurrentBlock().timestamp
        }
    }

    //
    // A Sale cut requirement for each listing to be listed on the Zeedz Marketplace, updatable by the administrator.
    // Contains a FungibleToken reciever capability for the sale cut recieving address and a ratio which defines the percentage of the sale cut.
    //
    pub struct SaleCutRequirement {
        pub let receiver: Capability<&{FungibleToken.Receiver}>

        pub let ratio: UFix64

        init(receiver: Capability<&{FungibleToken.Receiver}>, ratio: UFix64) {
            pre {
                ratio <= 1.0: ""ratio must be less than or equal to 1.0""
            }
            self.receiver = receiver
            self.ratio = ratio
        }
    }

    pub let ZeedzMarketplaceAdminStoragePath: StoragePath

    // listingID order by time, listingID asc
    access(contract) let listingIDs: [UInt64]

    // listingID => item
    access(contract) let listingIDItems: {UInt64: Item}

    // collection identifier => (NFT id => listingID)
    access(contract) let collectionNFTListingIDs: {String: {UInt64: UInt64}}

    // {Type of the FungibleToken => array of SaleCutRequirements}
    access(contract) var saleCutRequirements: {String : [SaleCutRequirement]}

    //
    // Administrator resource, owner account can update the Zeedz Marketplace sale cut requirements and remove listings.
    //
    pub resource Administrator {

        pub fun updateSaleCutRequirement(requirements: [SaleCutRequirement], vaultType: Type) {
            var totalRatio: UFix64 = 0.0
            for requirement in requirements {
                totalRatio = totalRatio + requirement.ratio
            }
            assert(totalRatio <= 1.0, message: ""total ratio must be less than or equal to 1.0"")
            ZeedzMarketplace.saleCutRequirements[vaultType.identifier] = requirements
        }

        pub fun forceRemoveListing(id: UInt64) {
            if let item = ZeedzMarketplace.listingIDItems[id] {
                ZeedzMarketplace.removeItem(item)
            }
        }
    }

    //
    // Adds a listing with the specified id and storefrontPublicCapability to the marketplace.
    //
    pub fun addListing(id: UInt64, storefrontPublicCapability: Capability<&{NFTStorefront.StorefrontPublic}>) {
        let item = Item(storefrontPublicCapability: storefrontPublicCapability, listingID: id)

        let indexToInsertListingID = self.getIndexToAddListingID(item: item, items: self.listingIDs)

        self.addItem(
            item,
            storefrontPublicCapability: storefrontPublicCapability,
            indexToInsertListingID: indexToInsertListingID)
    }

    //
    // Can be used by anyone to remove a listing if the listed item has been removed or purchased.
    //
    pub fun removeListing(id: UInt64) {
        if let item = self.listingIDItems[id] {
            // Skip if the listing item hasn't been purchased
            if let storefrontPublic = item.storefrontPublicCapability.borrow() {
                if let listingItem = storefrontPublic.borrowListing(listingResourceID: id) {
                    let listingDetails = listingItem.getDetails()
                    if listingDetails.purchased == false {
                        return
                    }
                }
            }

            self.removeItem(item)
        }
    }

    //
    // Returns an array of all listingsIDs currently listend on the marketplace.
    //
    pub fun getListingIDs(): [UInt64] {
        return self.listingIDs
    }

    //
    // Returns the item listed with the specified listingID.
    //
    pub fun getListingIDItem(listingID: UInt64): Item? {
        return self.listingIDItems[listingID]
    }

    //
    // Returns the listingID of the item from the specified nftType and nftID.
    //
    pub fun getListingID(nftType: Type, nftID: UInt64): UInt64? {
        let nftListingIDs = self.collectionNFTListingIDs[nftType.identifier] ?? {}
        return nftListingIDs[nftID]
    }

    //
    // Returns an array of the current marketplace SaleCutRequirements 
    //
    pub fun getAllSaleCutRequirements(): {String: [SaleCutRequirement]} {
        return self.saleCutRequirements
    }

    //
    // Returns an array of the current marketplace SaleCutRequirements for the specified VaultType
    //
    pub fun getVaultTypeSaleCutRequirements(vaultType: Type): [SaleCutRequirement]? {
        return self.saleCutRequirements[vaultType.identifier]
    }

    // 
    // Helper function to add an item to the marketplace
    //
    access(contract) fun addItem(
        _ item: Item,
        storefrontPublicCapability: Capability<&{NFTStorefront.StorefrontPublic}>,
        indexToInsertListingID: Int
    ) {
        pre {
            self.listingIDItems[item.listingID] == nil: ""could not add duplicate listing""
        }

        assert(item.listingDetails.purchased == false, message: ""the item has been purchased"")

        // find previous duplicate NFT
        let nftListingIDs = self.collectionNFTListingIDs[item.listingDetails.nftType.identifier]
        var previousItem: Item? = nil
        if let nftListingIDs = nftListingIDs {
            if let listingID = nftListingIDs[item.listingDetails.nftID] {
                previousItem = self.listingIDItems[listingID]!

                // panic only if they're same address
                if previousItem!.storefrontPublicCapability.address == item.storefrontPublicCapability.address {
                    panic(""could not add duplicate NFT"")
                }
            }
        }
        
        // check sale cut
        if let requirements = self.saleCutRequirements[item.listingDetails.salePaymentVaultType.identifier] {
            for requirement in requirements {
                let saleCutAmount = item.listingDetails.salePrice * requirement.ratio

                var match = false
                for saleCut in item.listingDetails.saleCuts {
                    if saleCut.receiver.address == requirement.receiver.address &&
                    saleCut.receiver.borrow()! == requirement.receiver.borrow()! {
                        if saleCut.amount >= saleCutAmount {
                            match = true
                        }
                        break
                    }
                }

                assert(match == true, message: ""saleCut must follow SaleCutRequirements"")
            }
        }

        // all by time
        self.listingIDs.insert(at: indexToInsertListingID, item.listingID)

        // update index data
        self.listingIDItems[item.listingID] = item
        if let nftListingIDs = nftListingIDs {
            nftListingIDs[item.listingDetails.nftID] = item.listingID
            self.collectionNFTListingIDs[item.listingDetails.nftType.identifier] = nftListingIDs
        } else {
            self.collectionNFTListingIDs[item.listingDetails.nftType.identifier] = {item.listingDetails.nftID: item.listingID}
        }

        // remove previous item
        if let previousItem = previousItem {
            self.removeItem(previousItem)
        }

        emit AddedListing(
            storefrontAddress: storefrontPublicCapability.address,
            listingResourceID: item.listingID,
            nftType: item.listingDetails.nftType,
            nftID: item.listingDetails.nftID,
            ftVaultType: item.listingDetails.salePaymentVaultType,
            price: item.listingDetails.salePrice
        )
    }

    //
    // Helper function to remove item. The indexes will be found automatically.
    //
    access(contract) fun removeItem(_ item: Item) {
        let indexToRemoveListingID = self.getIndexToRemoveListingID(
            item: item,
            items: self.listingIDs)

        self.removeItemWithIndexes(
            item,
            indexToRemoveListingID: indexToRemoveListingID)
    }

    //
    // Helper function to remove item with index. The index should be checked before calling this function.
    //
    access(contract) fun removeItemWithIndexes(_ item: Item, indexToRemoveListingID: Int?) {
        // remove from listingIDs
        if let indexToRemoveListingID = indexToRemoveListingID {
            self.listingIDs.remove(at: indexToRemoveListingID)
        }

        // update index data
        self.listingIDItems.remove(key: item.listingID)
        let nftListingIDs = self.collectionNFTListingIDs[item.listingDetails.nftType.identifier] ?? {}
        nftListingIDs.remove(key: item.listingDetails.nftID)
        self.collectionNFTListingIDs[item.listingDetails.nftType.identifier] = nftListingIDs

        emit RemovedListing(
            listingResourceID: item.listingID,
            nftType: item.listingDetails.nftType,
            nftID: item.listingDetails.nftID,
            ftVaultType: item.listingDetails.salePaymentVaultType,
            price: item.listingDetails.salePrice,
        )
    }

    //
    // Run reverse for loop to find out the index to insert.
    //
    access(contract) fun getIndexToAddListingID(item: Item, items: [UInt64]): Int {
        var index = items.length - 1
        while index >= 0 {
            let currentListingID = items[index]
            let currentItem = self.listingIDItems[currentListingID]!

            if item.timestamp == currentItem.timestamp {
                if item.listingID > currentListingID {
                    break
                }
                index = index - 1
            } else {
                break
            }
        }
        return index + 1
    }

    //
    // Run binary search to find the listing ID.
    //
    access(contract) fun getIndexToRemoveListingID(item: Item, items: [UInt64]): Int? {
        var startIndex = 0
        var endIndex = items.length

        while startIndex < endIndex {
            var midIndex = startIndex + (endIndex - startIndex) / 2
            var midListingID = items[midIndex]!
            var midItem = self.listingIDItems[midListingID]!

            if item.timestamp > midItem.timestamp {
                startIndex = midIndex + 1
            } else if item.timestamp < midItem.timestamp {
                endIndex = midIndex
            } else {
                if item.listingID > midListingID {
                    startIndex = midIndex + 1
                }  else if item.listingID < midListingID {
                    endIndex = midIndex
                } else {
                    return midIndex
                }
            }
        }
        return nil
    }

    init () {
        self.ZeedzMarketplaceAdminStoragePath = /storage/ZeedzMarketplaceAdmin

        self.listingIDs = []
        self.listingIDItems = {}
        self.collectionNFTListingIDs = {}
        self.saleCutRequirements = {}

        let admin <- create Administrator()
        self.account.save(<-admin, to: self.ZeedzMarketplaceAdminStoragePath)
    }
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This script returns an array of all the Zeedz NFT IDs in an account's collection.
*/

pub fun main(address: Address): [{String: AnyStruct}] {
    let account = getAccount(address)

    let collectionRef = account.getCapability(ZeedzINO.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic(""Could not borrow capability from public collection"")

    let collectionBorrow = account.getCapability(ZeedzINO.CollectionPublicPath)!.borrow<&{ZeedzINO.ZeedzCollectionPublic}>() 
        ?? panic(""Could not borrow ZeedzCollectionPublic"")
    
    let ids = collectionRef.getIDs()

    let returnArray: [{String: AnyStruct}] = [ ]

    for id in ids {
        let zeedle = collectionBorrow.borrowZeedle(id: id)
            ?? panic(""No such zeedleID in that collection"")
        let zeedleMetadata = zeedle.getMetadata()
        returnArray.append(zeedleMetadata)
    }
   
    return returnArray
}"
s.0000000000000000,
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This script returns the size of an account's ZeedzINO collection.
*/

pub fun main(address: Address): Int {
    let account = getAccount(address)

    let collectionRef = account.getCapability(ZeedzINO.CollectionPublicPath)!
        .borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic(""Could not borrow capability from public collection"")
    
    return collectionRef.getIDs().length
}"
s.0000000000000000,"import ZeedzINO from 0x0

/*
    This scripts returns the number of Zeedz currently in existence.
*/

pub fun main(): {UInt32: UInt64} {    
    return ZeedzINO.getMintedPerType()
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This script returns the metadata for a Zeedle NFT in an account's collection.
*/

pub fun main(address: Address, zeedleID: UInt64): {String: AnyStruct} {

    let owner = getAccount(address)

    let collectionBorrow = owner.getCapability(ZeedzINO.CollectionPublicPath)!
        .borrow<&{ZeedzINO.ZeedzCollectionPublic}>()
        ?? panic(""Could not borrow ZeedzCollectionPublic"")

    let Zeedle = collectionBorrow.borrowZeedle(id: zeedleID)
        ?? panic(""No such zeedleID in that collection"")

    return Zeedle.getMetadata()
}"
s.0000000000000000,"import ZeedzINO from 0x0

pub fun main(address: Address): Bool {
    let owner = getAccount(address)
    if (owner.getCapability<&{ZeedzINO.AdminClient}>(ZeedzINO.AdminClientPublicPath)
                .borrow() != nil) {
                return owner.getCapability<&{ZeedzINO.AdminClient}>(ZeedzINO.AdminClientPublicPath)
                .borrow()!.isAdmin()
                }
    else {
        return false
    }
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This script returns an array of all the Zeedz NFT IDs in an account's collection.
*/

pub fun main(address: Address): [UInt64] {
    let account = getAccount(address)

    let collectionRef = account.getCapability(ZeedzINO.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic(""Could not borrow capability from public collection"")
    
    return collectionRef.getIDs()
}"
s.0000000000000000,"import ZeedzINO from 0x0

/*
    This scripts returns the number of Zeedz currently in existence.
*/

pub fun main(): UInt64 {    
    return ZeedzINO.totalSupply
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This script returns the metadata for a Zeedle NFT in an account's collection.
*/

pub fun main(address: Address, zeedleID: UInt64): UInt64 {

    let owner = getAccount(address)

    let collectionBorrow = owner.getCapability(ZeedzINO.CollectionPublicPath)!
        .borrow<&{ZeedzINO.ZeedzCollectionPublic}>()
        ?? panic(""Could not borrow ZeedzCollectionPublic"")

    let Zeedle = collectionBorrow.borrowZeedle(id: zeedleID)
        ?? panic(""No such zeedleID in that collection"")

    return Zeedle.carbonOffset
}"
s.0000000000000000,"import ZeedzDrops from 0x0

pub fun main(): [UInt64] {    
    return ZeedzDrops.getAllProductIDs()
}"
s.0000000000000000,"import ZeedzDrops from 0x0

pub fun main(): {String : [ZeedzDrops.SaleCutRequirement]} {
    return ZeedzDrops.getAllSaleCutRequirements()
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This script returns the size of an account's ZeedzItems collection.

pub fun main(address: Address): Int {
    let account = getAccount(address)

    let collectionRef = account.getCapability(ZeedzItems.CollectionPublicPath)!
        .borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic(""Could not borrow capability from public collection"")
    
    return collectionRef.getIDs().length
}"
s.0000000000000000,"import ZeedzDrops from 0x0

pub fun main(productID: UInt64): ZeedzDrops.ProductDetails {   
    let productRef =  ZeedzDrops.getProduct(id: productID) ?? panic(""Product with specified id not found"")
    return productRef.getDetails()
}"
s.0000000000000000,"import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This scripts returns the number of ZeedzItems currently in existence.

pub fun main(): UInt64 {    
    return ZeedzItems.totalSupply
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This script returns the metadata for an NFT in an account's collection.

pub fun main(address: Address, itemID: UInt64): {String: String} {

    // get the public account object for the token owner
    let owner = getAccount(address)

    let collectionBorrow = owner.getCapability(ZeedzItems.CollectionPublicPath)!
        .borrow<&{ZeedzItems.ZeedzItemsCollectionPublic}>()
        ?? panic(""Could not borrow ZeedzItemsCollectionPublic"")

    // borrow a reference to a specific NFT in the collection
    let ZeedzItem = collectionBorrow.borrowZeedzItem(id: itemID)
        ?? panic(""No such itemID in that collection"")

    return ZeedzItem.getMetadata()
}"
s.0000000000000000,"import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0

pub fun main(offset: Int, limit: Int): DisplayResult {
    var listingIds: [UInt64] = ZeedzMarketplace.getListingIDs()

    var displayItems: [ListingDisplayItem] = []
    var limit = limit
    var skipCount = 0
    var index = offset
    while index < listingIds.length && limit >= 0 {
        let listingID = listingIds[index]
        if let item = getListingDisplayItem(listingID: listingID) {
            displayItems.append(item)
            limit = limit - 1
        } else {
            skipCount = skipCount + 1
        }
        index = index + 1
    }

    return DisplayResult(displayItems: displayItems, skipCount: skipCount)
}

pub struct ListingDisplayItem {

    pub let listingID: UInt64

    pub var address: Address

    // The identifier of type of the NonFungibleToken.NFT that is being listed.
    pub let nftType: String
    // The ID of the NFT within that type.
    pub let nftID: UInt64
    // The identifier of type of the FungibleToken that payments must be made in.
    pub let salePaymentVaultType: String
    // The amount that must be paid in the specified FungibleToken.
    pub let salePrice: UFix64
    // This specifies the division of payment between recipients.
    pub let saleCuts: [NFTStorefront.SaleCut]

    pub let timestamp: UFix64

    init (
        listingID: UInt64,
        address: Address,
        nftType: String,
        nftID: UInt64,
        salePaymentVaultType: String,
        salePrice: UFix64,
        saleCuts: [NFTStorefront.SaleCut],
        timestamp: UFix64
    ) {
        self.listingID = listingID
        self.address = address
        self.nftType = nftType
        self.nftID = nftID
        self.salePaymentVaultType = salePaymentVaultType
        self.salePrice = salePrice
        self.saleCuts = saleCuts
        self.timestamp = timestamp
    }
}

pub struct DisplayResult {
    pub let displayItems: [ListingDisplayItem]
    pub let skipCount: Int

    init(displayItems: [ListingDisplayItem], skipCount: Int) {
        self.displayItems = displayItems
        self.skipCount = skipCount
    }
}

pub fun getListingDisplayItem(listingID: UInt64): ListingDisplayItem? {
    if let item = ZeedzMarketplace.getListingIDItem(listingID: listingID) {
        if let storefrontPublic = item.storefrontPublicCapability.borrow() {
            if let listingPublic = storefrontPublic.borrowListing(listingResourceID: listingID) {
                let listingDetails = listingPublic.getDetails()

                if listingDetails.purchased == false {
                    return ListingDisplayItem(
                        listingID: listingID,
                        address: item.storefrontPublicCapability.address,
                        nftType: listingDetails.nftType.identifier,
                        nftID: listingDetails.nftID,
                        salePaymentVaultType: listingDetails.salePaymentVaultType.identifier,
                        salePrice: listingDetails.salePrice,
                        saleCuts: listingDetails.saleCuts,
                        timestamp: item.timestamp
                    )
                }
            }
        }
    }

    return nil
}"
s.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This script returns an array of all the NFT IDs in an account's collection.

pub fun main(address: Address): [UInt64] {
    let account = getAccount(address)

    let collectionRef = account.getCapability(ZeedzItems.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()
        ?? panic(""Could not borrow capability from public collection"")
    
    return collectionRef.getIDs()
}"
s.0000000000000000,
s.0000000000000000,"import ZeedzMarketplace from 0x0

pub fun main(): {String : [ZeedzMarketplace.SaleCutRequirement]} {
    return ZeedzMarketplace.getAllSaleCutRequirements()
}"
s.0000000000000000,"import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0

pub fun main(): [UInt64] {
    return ZeedzMarketplace.getListingIDs()
}"
s.0000000000000000,"import ZeedzMarketplace from 0x0

pub fun main(listingID: UInt64): ZeedzMarketplace.Item? {
    return ZeedzMarketplace.getListingIDItem(listingID: listingID)
}"
s.0000000000000000,"import ZeedzMarketplace from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

// Can be used by anyone to remove a listing if the listed item has been removed or purchased.
pub fun main(listingID: UInt64) {
         ZeedzMarketplace.removeListing(id: listingResourceID)
}"
s.0000000000000000,"import Marketplace from ""../../contracts/ZeedzMarketplace.cdc""

pub fun main() {
    log({""saleCutRequirements"": Marketplace.getSaleCutRequirements()})

    for listingID in Marketplace.getListingIDs() {
        let item = Marketplace.getListingIDItem(listingID: listingID)!
        logItem(item, listingID: listingID)
    }
}

pub fun logItem(_ item: Marketplace.Item, listingID: UInt64) {
    let storefrontPublic = item.storefrontPublicCapability.borrow() ?? panic(""Could not borrow public storefront from capability"")
    let listingPublic = storefrontPublic.borrowListing(listingResourceID: listingID) ?? panic(""no listing id"")
    let listingDetails = listingPublic.getDetails()
    log({""id"": listingID, ""nftID"": listingDetails.nftID})
    log({""price"": listingDetails.salePrice, ""tiemstamp"": item.timestamp})
}"
t.0000000000000000,"
   
// This transaction configures the signer's account with an empty FUSD vault.
//
// It also links the following capabilities:
//
// - FungibleToken.Receiver: this capability allows this account to accept FUSD deposits.
// - FungibleToken.Balance: this capability allows anybody to inspect the FUSD balance of this account.

import FungibleToken from 0x0
import FUSD from 0x0

transaction {

    prepare(signer: AuthAccount) {

        // It's OK if the account already has a Vault, but we don't want to replace it
        if(signer.borrow<&FUSD.Vault>(from: /storage/fusdVault) != nil) {
            return
        }
        
        // Create a new FUSD Vault and put it in storage
        signer.save(<-FUSD.createEmptyVault(), to: /storage/fusdVault)

        // Create a public capability to the Vault that only exposes
        // the deposit function through the Receiver interface
        signer.link<&FUSD.Vault{FungibleToken.Receiver}>(
            /public/fusdReceiver,
            target: /storage/fusdVault
        )

        // Create a public capability to the Vault that only exposes
        // the balance field through the Balance interface
        signer.link<&FUSD.Vault{FungibleToken.Balance}>(
            /public/fusdBalance,
            target: /storage/fusdVault
        )
    }
}"
t.0000000000000000,
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

/*
    This transaction configures an account to hold ZeedzINO & ZeedzItems
*/
transaction {
    prepare(signer: AuthAccount) {
    
    // Initialize ZeedzINO
    if signer.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath) == nil {
        signer.save(<-ZeedzINO.createEmptyCollection(), to: ZeedzINO.CollectionStoragePath)
        signer.unlink(ZeedzINO.CollectionPublicPath)
        signer.link<&ZeedzINO.Collection{NonFungibleToken.CollectionPublic, ZeedzINO.ZeedzCollectionPublic}>(ZeedzINO.CollectionPublicPath, target: ZeedzINO.CollectionStoragePath)
        }

    // Initialize ZeedzItems
    if signer.borrow<&ZeedzItems.Collection>(from: ZeedzItems.CollectionStoragePath) == nil {
        signer.save(<-ZeedzItems.createEmptyCollection(), to: ZeedzItems.CollectionStoragePath)
        signer.unlink(ZeedzItems.CollectionPublicPath)
        signer.link<&ZeedzItems.Collection{NonFungibleToken.CollectionPublic, ZeedzItems.ZeedzItemsCollectionPublic}>(ZeedzItems.CollectionPublicPath, target: ZeedzItems.CollectionStoragePath)
        }
    }
}"
t.0000000000000000,"import NFTStorefront from 0x0

// This transaction installs the Storefront ressource in an account.

transaction {
    prepare(acct: AuthAccount) {

        // If the account doesn't already have a Storefront
        if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {

            // Create a new empty .Storefront
            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront
            
            // save it to the account
            acct.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)

            // create a public capability for the .Storefront
            acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)
        }
    }
}"
t.0000000000000000,"import FungibleToken from 0x0
import TokenForwarding from 0x0
import DapperUtilityCoin from 0x0

transaction() {

	prepare(acct: AuthAccount) {
		// Get a Receiver reference for the Dapper account that will be the recipient of the forwarded DUC
		let dapper = getAccount(0xead892083b3e2c6c)
	  let dapperDUCReceiver = dapper.getCapability(/public/dapperUtilityCoinReceiver)!

	  // Create a new Forwarder resource for DUC and store it in the new account's storage
	  let ducForwarder <- TokenForwarding.createNewForwarder(recipient: dapperDUCReceiver)
	  acct.save(<-ducForwarder, to: /storage/dapperUtilityCoinReceiver)

	  // Publish a Receiver capability for the new account, which is linked to the DUC Forwarder
	  acct.link<&{FungibleToken.Receiver}>(
      /public/dapperUtilityCoinReceiver,
      target: /storage/dapperUtilityCoinReceiver
	  )
	}
}"
t.0000000000000000,"// This script is used to add a Vault resource to their account so that they can use FiatToken 
//
// If the Vault already exist for the account, the script will return immediately without error
// 
// If not onchain-multisig is required, pubkeys and key weights can be empty
// Vault resource must follow the FuntibleToken interface where initialiser only takes the balance
// As a result, the Vault owner is required to directly add public keys to the OnChainMultiSig.Manager
// via the `addKeys` method in the OnchainMultiSig.KeyManager interface.
// 
// Therefore if multisig is required for the vault, the account itself should have the same key weight
// distribution as it does for the Vault.
import FungibleToken from 0x0
import FiatToken from 0x0
import OnChainMultiSig from 0x0

transaction() {

    prepare(signer: AuthAccount) {

        // Return early if the account already stores a FiatToken Vault
        if signer.borrow<&FiatToken.Vault>(from: FiatToken.VaultStoragePath) != nil {
            return
        }

        // Create a new ExampleToken Vault and put it in storage
        signer.save(
            <-FiatToken.createEmptyVault(),
            to: FiatToken.VaultStoragePath
        )

        // Create a public capability to the Vault that only exposes
        // the deposit function through the Receiver interface
        signer.link<&FiatToken.Vault{FungibleToken.Receiver}>(
            FiatToken.VaultReceiverPubPath,
            target: FiatToken.VaultStoragePath
        )

        // Create a public capability to the Vault that only exposes
        // the UUID() function through the VaultUUID interface
        signer.link<&FiatToken.Vault{FiatToken.ResourceId}>(
            FiatToken.VaultUUIDPubPath,
            target: FiatToken.VaultStoragePath
        )

        // Create a public capability to the Vault that only exposes
        // the balance field through the Balance interface
        signer.link<&FiatToken.Vault{FungibleToken.Balance}>(
            FiatToken.VaultBalancePubPath,
            target: FiatToken.VaultStoragePath
        )

    }
}"
t.0000000000000000,
t.0000000000000000,"import ZeedzINO from 0x0
import NonFungibleToken from 0x0

transaction(recipient: Address, typeID: UInt32, metadata: {String : String}) {

    // local variable for storing the adminClientRef reference
    let adminClientRef: &ZeedzINO.ZeedzINOAdminClient

    prepare(admin: AuthAccount) {
        // borrow a reference to the Administrator resource in storage
        self.adminClientRef = admin.borrow<&ZeedzINO.ZeedzINOAdminClient>(from: ZeedzINO.AdminClientStoragePath)
            ?? panic(""Signer is not an admin"")
    }

    execute {        
        // get the public account object for the recipient
        let recipient = getAccount(recipient)

        // borrow the recipient's public NFT collection reference
        let receiver = recipient
            .getCapability(ZeedzINO.CollectionPublicPath)!
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic(""Could not get receiver reference to the NFT Collection"")
        
        self.adminClientRef.mintNFT(recipient: receiver, typeID: typeID, metadata: metadata)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

// This transction uses the Administrator resource to mint a new NFT.
//
// It must be run with the account that has the minter resource
// stored at path /storage/ZeedzINOMinter.

transaction(recipient: Address, name: String, description: String, typeID: UInt32, serialNumber: String, edition: UInt32, editionCap: UInt32, evolutionStage: UInt32, rarity: String, imageURI: String) {
    
    // local variable for storing the minter reference
   let minter: &ZeedzINO.Administrator

    prepare(signer: AuthAccount) {
        // borrow a reference to the Administrator resource in storage
       self.minter = signer.getCapability(ZeedzINO.AdminPrivatePath)
            .borrow<&ZeedzINO.Administrator>()!
    }


    execute {
        // get the public account object for the recipient
        let recipient = getAccount(recipient)

        // borrow the recipient's public NFT collection reference
        let receiver = recipient
            .getCapability(ZeedzINO.CollectionPublicPath)!
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic(""Could not get receiver reference to the NFT Collection"")

        // mint the NFT and deposit it to the recipient's collection
        self.minter.mintNFT(recipient: receiver, name: name, description: description, typeID: typeID, serialNumber: serialNumber, edition: edition, editionCap: editionCap, evolutionStage: evolutionStage, rarity: rarity, imageURI: imageURI)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

transaction(zeedleID: UInt64, amount: UInt64) {

    // local variable for storing the Admin reference
    let adminRef: &ZeedzINO.Administrator
    // local variable for storing the Zeedle reference
    let zeedleRef: &ZeedzINO.NFT

    prepare(owner: AuthAccount, admin: AuthAccount) {
        // borrow a reference to the Owner's collection
        let collectionBorrow = owner.getCapability(ZeedzINO.CollectionPublicPath)!
            .borrow<&{ZeedzINO.ZeedzCollectionPublic}>()
            ?? panic(""Could not borrow ZeedzCollectionPublic"")

        // borrow a reference to the Zeedle
        self.zeedleRef = collectionBorrow.borrowZeedle(id: zeedleID)
            ?? panic(""No such zeedleID in that collection"")

        // borrow a reference to the Administrator resource in storage
        self.adminRef= admin.getCapability(ZeedzINO.AdminPrivatePath)
            .borrow<&ZeedzINO.Administrator>()!
    }

    execute {
        self.adminRef.increaseOffset(zeedleRef: self.zeedleRef, amount: amount)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

// This transction uses the Administrator resource to mint a new NFT.
//
// It must be run with the account that has the minter resource
// stored at path /storage/ZeedzINOMinter.

transaction(recipient: Address, zeedles: [{String : String}]) {
    
      // local variable for storing the minter reference
     let minter: &ZeedzINO.Administrator
  
      prepare(signer: AuthAccount) {
          // borrow a reference to the Administrator resource in storage
         self.minter = signer.getCapability(ZeedzINO.AdminPrivatePath)
              .borrow<&ZeedzINO.Administrator>()!
      }
  
  
      execute {
          // get the public account object for the recipient
          let recipient = getAccount(recipient)
  
          // borrow the recipient's public NFT collection reference
          let receiver = recipient
              .getCapability(ZeedzINO.CollectionPublicPath)!
              .borrow<&{NonFungibleToken.CollectionPublic}>()
              ?? panic(""Could not get receiver reference to the NFT Collection"")

          // mint the NFTs and deposit it to the recipient's collection
          for zeedle in zeedles {
            self.minter.mintNFT(recipient: receiver, name: zeedle[""name""]!, description: zeedle[""description""]!, typeID: stringToUInt32(zeedle[""typeID""]!), serialNumber: zeedle[""serialNumber""]!, edition: stringToUInt32(zeedle[""edition""]!), editionCap: stringToUInt32(zeedle[""editionCap""]!), evolutionStage: stringToUInt32(zeedle[""evolutionStage""]!), rarity: zeedle[""rarity""]!, imageURI: zeedle[""imageURI""]!)
          }
      }
  }

pub fun stringToUInt32(_ string: String): UInt32{
    var number = 0
    var i = 0
    while i < string.length {
        number = number + getDigit(string.slice(from: i, upTo: i+1))*powerOf(10,string.length - i - 1 )
        i = i + 1;
    }
    return UInt32(number)
}

pub fun getDigit(_ string: String): Int {
    let digits: {String: Int} = {""0"" : 0, ""1"" : 1, ""2"" :2, ""3"" :3, ""4"" :4, ""5"": 5, ""6"" :6, ""7"" :7, ""8"": 8, ""9"" :9}
    return digits[string]!
}

pub fun powerOf(_ base: Int,_ exponent: Int): Int {
    var i = 0
    var number = 1
    while i < exponent {
        if (exponent > 0 ) {
            number = number * base
            i = i + 1;
        } 
        if (exponent == 0) {
            break
        }
         if (exponent < 0) {
            number = number / base
            i = i - 1;
        }
    }
    return number
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

transaction(zeedleID: UInt64) {
    
    let zeedleProvider: &AnyResource{ZeedzINO.ZeedzCollectionPrivate}

    prepare(signer: AuthAccount) {

        // borrow a reference to the signer's NFT collection
        self.zeedleProvider = signer.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath)
            ?? panic(""Could not borrow a reference to the owner's collection"")
            
    }

    execute {
        self.zeedleProvider.burn(burnID: zeedleID)
    }
}"
t.0000000000000000,"
import ZeedzINO from 0x0

/* 
    This transaction gives an user the administrator capability
*/ 

transaction() {

    let clientCapability: &AnyResource{ZeedzINO.AdminClient}
    let adminCapability: Capability<&ZeedzINO.Administrator>

    prepare(signer: AuthAccount, admin: AuthAccount) {

        self.adminCapability =admin.getCapability<&ZeedzINO.Administrator>(ZeedzINO.AdminPrivatePath)

        // borrow a reference to the Administrator resource in storage
        let adminRef= admin.getCapability(ZeedzINO.AdminPrivatePath)
            .borrow<&ZeedzINO.Administrator>()!

        if (signer.getCapability<&{ZeedzINO.AdminClient}>(ZeedzINO.AdminClientPublicPath).borrow() == nil) {
            signer.save(<- adminRef.createAdminClient(), to: ZeedzINO.AdminClientStoragePath)
            signer.link<&{ZeedzINO.AdminClient}>(ZeedzINO.AdminClientPublicPath, target: ZeedzINO.AdminClientStoragePath)
        }

        self.clientCapability= signer.getCapability<&{ZeedzINO.AdminClient}>(ZeedzINO.AdminClientPublicPath)
            .borrow() ?? panic(""Could not borrow admin client"")
    }

    execute {
          self.clientCapability.addCapability(self.adminCapability)
    }
}
"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0
import FungibleToken from 0x0

transaction(claimIDs: [UInt64]) {
    prepare(recipient: AuthAccount, admin: AuthAccount) {
        // Initialize the colleciton
        if recipient.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath) == nil {
                recipient.save(<-ZeedzINO.createEmptyCollection(), to: ZeedzINO.CollectionStoragePath)
                recipient.unlink(ZeedzINO.CollectionPublicPath)
                recipient.link<&ZeedzINO.Collection{NonFungibleToken.CollectionPublic, ZeedzINO.ZeedzCollectionPublic}>(ZeedzINO.CollectionPublicPath, target: ZeedzINO.CollectionStoragePath)
            }

        // Get admin collection reference
        let adminRef = admin.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath)
            ?? panic(""Could not borrow a reference to the admin's collection"")

        // Get recipient capability reference
        let depositRef = recipient.getCapability(ZeedzINO.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()!

        // Claim all NFTs
        for claimID in claimIDs {
            //  Transfer amount
            let amount: UFix64 = 0.00002

            //  Withdraw ""amount"" from admin and store in a temporary ""transfer"" vault
            let transfer <- admin.borrow<&{FungibleToken.Provider}>(from: /storage/flowTokenVault)!.withdraw(amount: amount)

            //  Deposit ""amount"" from temporary ""transfer"" vault into ""to"" accounts public receiver
            recipient.getCapability<&{FungibleToken.Receiver}>(/public/flowTokenReceiver).borrow()!.deposit(from: <- transfer)

            //  Deposit NFT
            let nft <- adminRef.withdraw(withdrawID: claimID)
            depositRef.deposit(token: <-nft)
        }
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This transaction transfers a Zeedle from one account to another.
*/ 

transaction(recipient: Address, withdrawID: UInt64) {
    prepare(signer: AuthAccount) {
        
        // get the recipients public account object
        let recipient = getAccount(recipient)

        // borrow a reference to the signer's NFT collection
        let collectionRef = signer.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath)
            ?? panic(""Could not borrow a reference to the owner's collection"")

        // borrow a public reference to the receivers collection
        let depositRef = recipient.getCapability(ZeedzINO.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()!

        // withdraw the NFT from the owner's collection
        let nft <- collectionRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        depositRef.deposit(token: <-nft)
        
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzINO from 0x0

/*
    This transaction configures an account to hold Zeedz
*/

transaction {
    prepare(signer: AuthAccount) {
    // if the account doesn't already have a collection
     if signer.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath) == nil {
            signer.save(<-ZeedzINO.createEmptyCollection(), to: ZeedzINO.CollectionStoragePath)
            signer.unlink(ZeedzINO.CollectionPublicPath)
            signer.link<&ZeedzINO.Collection{NonFungibleToken.CollectionPublic, ZeedzINO.ZeedzCollectionPublic}>(ZeedzINO.CollectionPublicPath, target: ZeedzINO.CollectionStoragePath)
        }
    }
}   "
t.0000000000000000,"import ZeedzDrops from 0x0
import FUSD from 0x0
import FungibleToken from 0x0

transaction(productID: UInt64, userID: String, discount: UFix64) {

    let productRef: &ZeedzDrops.Product{ZeedzDrops.ProductPublic}
    let adminRef: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}
    let paymentVault: @FungibleToken.Vault
    let vaultType: Type

    prepare(acct: AuthAccount, admin: AuthAccount) {
        self.productRef =  ZeedzDrops.getProduct(id: productID) 
            ?? panic(""Product with specified id not found"")

        self.vaultType = Type<@FUSD.Vault>()

        let price = self.productRef.getDetails().getPrices()[self.vaultType.identifier]
            ?? panic(""Cannot get FUSD Token price for product"")

        let mainFUSDVault = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault)
            ?? panic(""Cannot borrow FUSD vault from acct storage"")

        let discountedPrice = price*(1.0-discount)

        self.paymentVault <- mainFUSDVault.withdraw(amount: discountedPrice)

        self.adminRef = admin.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
       self.adminRef.purchaseWithDiscount(productID: productID, payment: <- self.paymentVault, discount: discount, vaultType: self.vaultType, userID: userID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

transaction(productID: UInt64, userID: String, discount: UFix64) {

    let productRef: &ZeedzDrops.Product{ZeedzDrops.ProductPublic}
    let adminRef: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}
    let paymentVault: @FungibleToken.Vault
    let vaultType: Type

    prepare(acct: AuthAccount, admin: AuthAccount) {
        self.productRef =  ZeedzDrops.getProduct(id: productID) 
            ?? panic(""Product with specified id not found"")

        self.vaultType = Type<@FlowToken.Vault>()

        let price = self.productRef.getDetails().getPrices()[self.vaultType.identifier]
            ?? panic(""Cannot get Flow Token price for product"")

        let mainFlowVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic(""Cannot borrow FlowToken vault from acct storage"")

        let discountedPrice = price*(1.0-discount)

        self.paymentVault <- mainFlowVault.withdraw(amount: discountedPrice)

        self.adminRef = admin.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
       self.adminRef.purchaseWithDiscount(productID: productID, payment: <- self.paymentVault, discount: discount, vaultType: self.vaultType, userID: userID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FiatToken from 0x0
import FungibleToken from 0x0

transaction(productID: UInt64, userID: String, discount: UFix64) {

    let productRef: &ZeedzDrops.Product{ZeedzDrops.ProductPublic}
    let adminRef: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}
    let paymentVault: @FungibleToken.Vault
    let vaultType: Type

    prepare(acct: AuthAccount, admin: AuthAccount) {
        self.productRef =  ZeedzDrops.getProduct(id: productID) 
            ?? panic(""Product with specified id not found"")

        self.vaultType = Type<@FiatToken.Vault>()

        let price = self.productRef.getDetails().getPrices()[self.vaultType.identifier]
            ?? panic(""Cannot get Fiat Token price for product"")

        let mainFiatVault = acct.borrow<&FiatToken.Vault>(from: FiatToken.VaultStoragePath)
            ?? panic(""Cannot borrow FiatToken vault from acct storage"")

        let discountedPrice = price*(1.0-discount)

        self.paymentVault <- mainFiatVault.withdraw(amount: discountedPrice)

        self.adminRef = admin.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
       self.adminRef.purchaseWithDiscount(productID: productID, payment: <- self.paymentVault, discount: discount, vaultType: self.vaultType, userID: userID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

transaction(productID: UInt64, userID: String) {

    let productRef: &ZeedzDrops.Product{ZeedzDrops.ProductPublic}
    let paymentVault: @FungibleToken.Vault
    let vaultType: Type
    let adminRef: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount, admin: AuthAccount) {
        self.productRef =  ZeedzDrops.getProduct(id: productID) 
            ?? panic(""Product with specified id not found"")

        self.vaultType = Type<@FlowToken.Vault>()

        let price = self.productRef.getDetails().getPrices()[self.vaultType.identifier]
            ?? panic(""Cannot get Flow Token price for product"")

        let mainFlowVault = acct.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic(""Cannot borrow FlowToken vault from acct storage"")

        self.paymentVault <- mainFlowVault.withdraw(amount: price)

        self.adminRef = admin.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.adminRef.purchase(productID: productID, payment: <- self.paymentVault, vaultType: self.vaultType, userID: userID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FUSD from 0x0
import FungibleToken from 0x0

transaction(productID: UInt64, userID: String) {

    let productRef: &ZeedzDrops.Product{ZeedzDrops.ProductPublic}
    let paymentVault: @FungibleToken.Vault
    let vaultType: Type

    prepare(acct: AuthAccount) {
        self.productRef =  ZeedzDrops.getProduct(id: productID) 
            ?? panic(""Product with specified id not found"")

        self.vaultType = Type<@FUSD.Vault>()

        let price = self.productRef.getDetails().getPrices()[self.vaultType.identifier]
            ?? panic(""Cannot get FUSD Token price for product"")

        let mainFUSDVault = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault)
            ?? panic(""Cannot borrow FUSD vault from acct storage"")

        self.paymentVault <- mainFUSDVault.withdraw(amount: price)
    }

    execute {
       self.productRef.purchase(payment: <- self.paymentVault, vaultType: self.vaultType, userID: userID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FiatToken from 0x0
import FungibleToken from 0x0

transaction(productID: UInt64, userID: String) {

    let productRef: &ZeedzDrops.Product{ZeedzDrops.ProductPublic}
    let paymentVault: @FungibleToken.Vault
    let vaultType: Type

    prepare(acct: AuthAccount) {
        self.productRef =  ZeedzDrops.getProduct(id: productID) 
            ?? panic(""Product with specified id not found"")

        self.vaultType = Type<@FiatToken.Vault>()

        let price = self.productRef.getDetails().getPrices()[self.vaultType.identifier]
            ?? panic(""Cannot get Fiat Token price for product"")

        let mainFiatVault = acct.borrow<&FiatToken.Vault>(from: FiatToken.VaultStoragePath)
            ?? panic(""Cannot borrow FiatToken vault from acct storage"")

        self.paymentVault <- mainFiatVault.withdraw(amount: price)
    }

    execute {
       self.productRef.purchase(payment: <- self.paymentVault, vaultType: self.vaultType, userID: userID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(productID: UInt64) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.removeProduct(productID: productID)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(name: String, description: String, id: String, total: UInt64, saleEnabled: Bool, timeStart: UFix64, timeEnd: UFix64, prices: {String : UFix64}) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.addProduct(name: name, description: description, id: id, total: total, saleEnabled: saleEnabled, timeStart: timeStart, timeEnd: timeEnd, prices: prices)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(productID: UInt64, amount: UInt64) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.reserve(productID: productID, amount: amount)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(productID: UInt64, prices: {String: UFix64}) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.setPrices(productID: productID, prices: prices)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FlowToken from 0x0

transaction(name: String, description: String, id: String, total: UInt64, saleEnabled: Bool) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}
    let vaultType: Type

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
        self.vaultType = Type<@FlowToken.Vault>()
    }

    execute {
        let prices = { self.vaultType.identifier : 33.0}
        self.dropsAdmin.addProduct(name: name, description: description, id: id, total: total, saleEnabled: saleEnabled, timeStart: getCurrentBlock().timestamp, timeEnd: getCurrentBlock().timestamp+(600.0*10.0), prices: prices)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(productID: UInt64, endTime: UFix64) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.setEndTime(productID: productID, endTime: endTime)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(productID: UInt64, status: Bool) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.setSaleEnabledStatus(productID: productID, status: status)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0

transaction(productID: UInt64, startTime: UFix64) {

    let dropsAdmin: &ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}

    prepare(acct: AuthAccount) {
        self.dropsAdmin = acct.borrow<&ZeedzDrops.DropsAdmin{ZeedzDrops.ProductsManager}>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Missing or mis-typed admin resource"")
    }

    execute {
        self.dropsAdmin.setStartTime(productID: productID, startTime: startTime)
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

transaction(marketCut: Address) {

    prepare(signer: AuthAccount) {
        let marketRecipient = marketCut
        let marketRatio = 1.0 // 2.5%

        assert(marketRatio <= 1.0, message: ""total of ratio must be less than or equal to 1.0"")

        let adminRef = signer.borrow<&ZeedzDrops.DropsAdmin>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Cannot borrow drops admin"")

        let requirements: [ZeedzDrops.SaleCutRequirement] = []

        // market SaleCut
        if marketRatio > 0.0 {
            let marketFlowTokenReceiver = getAccount(marketCut).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            assert(marketFlowTokenReceiver.borrow() != nil, message: ""Missing or mis-typed market FlowToken receiver"")
            requirements.append(ZeedzDrops.SaleCutRequirement(receiver: marketFlowTokenReceiver, ratio: marketRatio))
        }

        adminRef.updateSaleCutRequirement(requirements: requirements, vaultType: Type<@FlowToken.Vault>())
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FiatToken from 0x0
import FungibleToken from 0x0

transaction(marketCut: Address) {

    prepare(signer: AuthAccount) {
        let marketRecipient = marketCut
        let marketRatio = 1.0 // 2.5%

        assert(marketRatio <= 1.0, message: ""total of ratio must be less than or equal to 1.0"")

        let adminRef = signer.borrow<&ZeedzDrops.DropsAdmin>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Cannot borrow drops admin"")

        let requirements: [ZeedzDrops.SaleCutRequirement] = []

        // market SaleCut
        if marketRatio > 0.0 {
            let marketFiatTokenReceiver = getAccount(marketCut).getCapability<&FiatToken.Vault{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)
            assert(marketFiatTokenReceiver.borrow() != nil, message: ""Missing or mis-typed market FiatToken receiver"")
            requirements.append(ZeedzDrops.SaleCutRequirement(receiver: marketFiatTokenReceiver, ratio: marketRatio))
        }

        adminRef.updateSaleCutRequirement(requirements: requirements, vaultType: Type<@FiatToken.Vault>())
    }
}"
t.0000000000000000,"import ZeedzDrops from 0x0
import FUSD from 0x0
import FungibleToken from 0x0

transaction(marketCut: Address) {

    prepare(signer: AuthAccount) {
        let marketRecipient = marketCut
        let marketRatio = 1.0 // 2.5%

        assert(marketRatio <= 1.0, message: ""total of ratio must be less than or equal to 1.0"")

        let adminRef = signer.borrow<&ZeedzDrops.DropsAdmin>(from: ZeedzDrops.ZeedzDropsStoragePath)
            ?? panic(""Cannot borrow drops admin"")

        let requirements: [ZeedzDrops.SaleCutRequirement] = []

        // market SaleCut
        if marketRatio > 0.0 {
            let marketFUSDReceiver = getAccount(marketCut).getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceive)
            assert(marketFUSDReceiver.borrow() != nil, message: ""Missing or mis-typed market FUSD receiver"")
            requirements.append(ZeedzDrops.SaleCutRequirement(receiver: marketFUSDReceiver, ratio: marketRatio))
        }

        adminRef.updateSaleCutRequirement(requirements: requirements, vaultType: Type<@FUSD.Vault>())
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""
transaction(itemID: UInt64) {
    
    let itemProvider: &AnyResource{ZeedzItems.ZeedzItemsCollectionPrivate}

    prepare(signer: AuthAccount) {

        // borrow a reference to the signer's NFT collection
        self.itemProvider = signer.borrow<&ZeedzItems.Collection>(from: ZeedzItems.CollectionStoragePath)
            ?? panic(""Could not borrow a reference to the owner's collection"")
            
    }

    execute {
        self.itemProvider.burn(burnID: itemID)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This transaction transfers a Zeedz Item from one account to another.

transaction(recipient: Address, withdrawID: UInt64) {
    prepare(signer: AuthAccount) {
        
        // get the recipients public account object
        let recipient = getAccount(recipient)

        // borrow a reference to the signer's NFT collection
        let collectionRef = signer.borrow<&ZeedzItems.Collection>(from: ZeedzItems.CollectionStoragePath)
            ?? panic(""Could not borrow a reference to the owner's collection"")

        // borrow a public reference to the receivers collection
        let depositRef = recipient.getCapability(ZeedzItems.CollectionPublicPath)!.borrow<&{NonFungibleToken.CollectionPublic}>()!

        // withdraw the NFT from the owner's collection
        let nft <- collectionRef.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        depositRef.deposit(token: <-nft)
        
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This transction uses the NFTMinter resource to mint a new NFT.
//
// It must be run with the account that has the minter resource
// stored at path /storage/ZeedzItemsMinter.

transaction(recipient: Address, typeID: UInt64, metadata: {String : String}) {
    
    // local variable for storing the minter reference
   let minter: &ZeedzItems.Administrator

    prepare(signer: AuthAccount) {
        // borrow a reference to the Administrator resource in storage
       self.minter = signer.getCapability(ZeedzItems.AdminPrivatePath)
            .borrow<&ZeedzItems.Administrator>()!
    }


    execute {
        // get the public account object for the recipient
        let recipient = getAccount(recipient)

        // borrow the recipient's public NFT collection reference
        let receiver = recipient
            .getCapability(ZeedzItems.CollectionPublicPath)!
            .borrow<&{NonFungibleToken.CollectionPublic}>()
            ?? panic(""Could not get receiver reference to the NFT Collection"")

        // mint the NFT and deposit it to the recipient's collection
        self.minter.mintNFT(recipient: receiver, typeID: typeID, metadata: metadata)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import ZeedzItems from ""../../contracts/ZeedzItems.cdc""

// This transaction configures an account to hold Zeedz Items.

transaction {
    prepare(signer: AuthAccount) {
    // if the account doesn't already have a collection
     if signer.borrow<&ZeedzItems.Collection>(from: ZeedzItems.CollectionStoragePath) == nil {
          signer.save(<-ZeedzItems.createEmptyCollection(), to: ZeedzItems.CollectionStoragePath)
        }
        signer.unlink(ZeedzItems.CollectionPublicPath)
        signer.link<&ZeedzItems.Collection{NonFungibleToken.CollectionPublic, ZeedzItems.ZeedzItemsCollectionPublic}>(ZeedzItems.CollectionPublicPath, target: ZeedzItems.CollectionStoragePath)
    }
}  "
t.0000000000000000,"import ZeedzMarketplace from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

// Used by admin to forcefully remove a listing withouth cheking if it has been removed or purchased.
transaction(listingID: UInt64) {

    prepare(signer: AuthAccount) {
        let admin = signer.borrow<&ZeedzMarketplace.Administrator>(from: ZeedzMarketplace.ZeedzMarketplaceAdminStoragePath)
            ?? panic(""Cannot borrow marketplace admin"")
        admin.forceRemoveListing(id: listingID)
    }
}"
t.0000000000000000,
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

transaction(listingResourceID: UInt64, storefrontAddress: Address, buyPrice: UFix64) {
    let paymentVault: @FungibleToken.Vault
    let nftReceiver: &ZeedzINO.Collection{NonFungibleToken.Receiver}
    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}
    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}

    prepare(signer: AuthAccount) {
        // Create a collection to store the purchase if none present
	    if signer.borrow<&ZeedzINO.Collection>(from: ZeedzINO.CollectionStoragePath) == nil {
		    signer.save(<-ZeedzINO.createEmptyCollection(), to: ZeedzINO.CollectionStoragePath)
		    signer.link<&ZeedzINO.Collection{NonFungibleToken.CollectionPublic,ZeedzINO.ZeedzCollectionPublic}>(
			    ZeedzINO.CollectionPublicPath,
			    target: ZeedzINO.CollectionStoragePath
		    )
	    }

        self.storefront = getAccount(storefrontAddress)
            .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
            .borrow()
            ?? panic(""Could not borrow Storefront from provided address"")

        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)
            ?? panic(""No Offer with that ID in Storefront"")
        let price = self.listing.getDetails().salePrice

        assert(buyPrice == price, message: ""buyPrice is NOT same with salePrice"")

        let flowTokenVault = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic(""Cannot borrow FlowToken vault from signer storage"")
        self.paymentVault <- flowTokenVault.withdraw(amount: price)

        self.nftReceiver = signer.borrow<&ZeedzINO.Collection{NonFungibleToken.Receiver}>(from: ZeedzINO.CollectionStoragePath)
            ?? panic(""Cannot borrow NFT collection receiver from account"")
    }

    execute {
        let item <- self.listing.purchase(payment: <-self.paymentVault)

        self.nftReceiver.deposit(token: <-item)

        // Be kind and recycle
        self.storefront.cleanup(listingResourceID: listingResourceID)
        ZeedzMarketplace.removeListing(id: listingResourceID)
    }

}"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import DapperUtilityCoin from 0x0
import FungibleToken from 0x0

transaction(storefrontAddress: Address, listingResourceID: UInt64, expectedPrice: UFix64, buyerAddress: Address) {
    let paymentVault: @FungibleToken.Vault
    let buyerNFTCollection: &ZeedzINO.Collection{NonFungibleToken.Receiver}
    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}
    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}
    let balanceBeforeTransfer: UFix64
    let mainDucVault: &DapperUtilityCoin.Vault

    // The Dapper Wallet admin Flow account will provide the authorizing signature,
    // which allows Dapper to purhase the NFT with DUC on behalf of the buyer
    prepare(dapper: AuthAccount) {
        self.storefront = getAccount(storefrontAddress)
            .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath
            )!
            .borrow()
            ?? panic(""Could not borrow Storefront from provided address"")

        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)
                    ?? panic(""No Offer with that ID in Storefront"")
        let salePrice = self.listing.getDetails().salePrice
        
        // Make sure the price on the listing matches the sale price argument. This is important
        // because Dapper uses the sale price argument to determine the amount to charge the user.
        if expectedPrice != salePrice {
            panic(""Sale price not expected value"")
        }

        // Because Dapper signed as the authorizer, we can borrow a reference 
        // to Dapper admin's account DUC vault to withdraw the amount required 
        // to purchase the NFT
        self.mainDUCVault = dapper.borrow<&DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)
					?? panic(""Could not borrow reference to Dapper Utility Coin vault"")
        self.balanceBeforeTransfer = self.mainDucVault.balance
        self.paymentVault <- self.mainDUCVault.withdraw(amount: salePrice)

        self.buyerNFTCollection = getAccount(buyerAddress)
            .getCapability<&ZeedzINO.Collection{NonFungibleToken.Receiver}>(
                ZeedzINO.CollectionPublicPath
            )
            .borrow()
            ?? panic(""Cannot borrow ZeedzINO collection receiver from buyerAddress"")
    }

    execute {
        let item <- self.listing.purchase(
            payment: <-self.paymentVault
        )

        self.buyerNFTCollection.deposit(token: <-item)

        ZeedzMarketplace.removeListing(id: listingResourceID)

        // Assert that no DUC has leaked from the Dapper system
        if self.mainDucVault.balance != self.balanceBeforeTransfer {
            panic(""DUC leakage"")
        }
    }
}
```"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import DapperUtilityCoin from 0x0
import FungibleToken from 0x0

transaction(storefrontAddress: Address, listingResourceID: UInt64, expectedPrice: UFix64, buyerAddress: Address) {
    let paymentVault: @FungibleToken.Vault
    let buyerNFTCollection: &ZeedzINO.Collection{NonFungibleToken.Receiver}
    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}
    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}
    let balanceBeforeTransfer: UFix64
    let mainDucVault: &DapperUtilityCoin.Vault
    let adminRef: &ZeedzINO.Administrator
    let buyerZeedzPublic: &ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic}

    // The Dapper Wallet admin Flow account will provide the authorizing signature,
    // which allows Dapper to purhase the NFT with DUC on behalf of the buyer
    prepare(signer: AuthAccount, admin: AuthAccount, dapper: AuthAccount) {
        self.storefront = getAccount(storefrontAddress)
            .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath
            )!
            .borrow()
            ?? panic(""Could not borrow Storefront from provided address"")

        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)
                    ?? panic(""No Offer with that ID in Storefront"")
        let salePrice = self.listing.getDetails().salePrice
        
        // Make sure the price on the listing matches the sale price argument. This is important
        // because Dapper uses the sale price argument to determine the amount to charge the user.
        if expectedPrice != salePrice {
            panic(""Sale price not expected value"")
        }

        // Because Dapper signed as the authorizer, we can borrow a reference 
        // to Dapper admin's account DUC vault to withdraw the amount required 
        // to purchase the NFT
        self.mainDUCVault = dapper.borrow<&DapperUtilityCoin.Vault>(from: /storage/dapperUtilityCoinVault)
					?? panic(""Could not borrow reference to Dapper Utility Coin vault"")
        self.balanceBeforeTransfer = self.mainDucVault.balance
        self.paymentVault <- self.mainDUCVault.withdraw(amount: salePrice)

        self.buyerNFTCollection = getAccount(buyerAddress)
            .getCapability<&ZeedzINO.Collection{NonFungibleToken.Receiver}>(
                ZeedzINO.CollectionPublicPath
            )
            .borrow()
            ?? panic(""Cannot borrow ZeedzINO collection receiver from buyerAddress"")

            // borrow a reference to the Administrator resource in storage
        self.adminRef= admin.getCapability(ZeedzINO.AdminPrivatePath)
            .borrow<&ZeedzINO.Administrator>()!

        self.buyerZeedzPublic = signer.getCapability<&ZeedzINO.Collection{ZeedzINO.ZeedzCollectionPublic}>(ZeedzINO.CollectionPublicPath)
            .borrow()
            ?? panic(""Could not borrow ZeedzCollectionPublic"")
    }

    execute {
        let item <- self.listing.purchase(
            payment: <-self.paymentVault
        )

        let zeedleID = item.id

        let zeedleRef = self.buyerZeedzPublic.borrowZeedle(id: zeedleID)
            ?? panic(""No such zeedleID in that collection"")

        self.buyerNFTCollection.deposit(token: <-item)

        self.adminRef.increaseOffset(zeedleRef: zeedleRef, amount: UInt64(Int(buyPrice) * 420))

        ZeedzMarketplace.removeListing(id: listingResourceID)

        // Assert that no DUC has leaked from the Dapper system
        if self.mainDucVault.balance != self.balanceBeforeTransfer {
            panic(""DUC leakage"")
        }
    }
}
```"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import DapperUtilityCoin from 0x0
import FungibleToken from 0x0

transaction(saleItemID: UInt64, saleItemPrice: UFix64) {
    let ducReceiver: Capability<&DapperUtilityCoin.Vault{FungibleToken.Receiver}>
    let nftProvider: Capability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
    let storefront: &NFTStorefront.Storefront
    let storefrontPublic: Capability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>

    prepare(signer: AuthAccount) {
        // Create Storefront if it doesn't exist
        if signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {
            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront
            signer.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)
            signer.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath,
                target: NFTStorefront.StorefrontStoragePath)
        }

        // We need a provider capability, but one is not provided by default so we create one if needed.
        let nftCollectionProviderPrivatePath = /private/zeedzINONFTCollectionProviderForNFTStorefront
        if !signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!.check() {
            signer.link<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath, target: ZeedzINO.CollectionStoragePath)
        }

        self.ducReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/dapperUtilityCoinReceiver)!
        assert(self.ducReceiver.borrow() != nil, message: ""Missing or mis-typed DUC receiver"")

        self.nftProvider = signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!
        assert(self.nftProvider.borrow() != nil, message: ""Missing or mis-typed ZeedzINO.Collection provider"")

        self.storefront = signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)
            ?? panic(""Missing or mis-typed NFTStorefront Storefront"")

        self.storefrontPublic = signer.getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
        assert(self.storefrontPublic.borrow() != nil, message: ""Could not borrow public storefront from address"")
    }

    execute {
        // Remove old listing
        if let listingID = ZeedzMarketplace.getListingID(nftType: Type<@ZeedzINO.NFT>(), nftID: saleItemID) {
            let listingIDs = self.storefront.getListingIDs()
            if listingIDs.contains(listingID) {
                self.storefront.removeListing(listingResourceID: listingID)
            }
            ZeedzMarketplace.removeListing(id: listingID)
        }

        // Create SaleCuts
        var saleCuts: [NFTStorefront.SaleCut] = []
        let requirements = ZeedzMarketplace.getAllSaleCutRequirements()
        var remainingPrice = saleItemPrice
        for requirement in requirements {
            let price = saleItemPrice * requirement.ratio
            saleCuts.append(NFTStorefront.SaleCut(
                receiver: requirement.receiver,
                amount: price
            ))
            remainingPrice = remainingPrice - price
        }
        saleCuts.append(NFTStorefront.SaleCut(
            receiver: self.flowTokenReceiver,
            amount: remainingPrice
        ))

        // Add listing
        let id = self.storefront.createListing(
            nftProviderCapability: self.nftProvider,
            nftType: Type<@ZeedzINO.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@DapperUtilityCoin.Vault>(),
            saleCuts: saleCuts
        )
        ZeedzMarketplace.addListing(id: id, storefrontPublicCapability: self.storefrontPublic)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0
import ZeedzINO from 0x0

transaction(listingResourceID: UInt64, storefrontAddress: Address, buyPrice: UFix64) {
    let paymentVault: @FungibleToken.Vault
    let nftReceiver: &ZeedzINO.Collection{NonFungibleToken.Receiver}
    let nftCollection: &AnyResource{ZeedzINO.ZeedzCollectionPublic}
    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}
    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}
    let adminRef: &ZeedzINO.Administrator

    prepare(signer: AuthAccount, admin: AuthAccount) {
	    if signer.borrow<&ZeedzINO.Collection>(from: /storage/ZeedzINOCollection) == nil {
		    signer.save(<-ZeedzINO.createEmptyCollection(), to: /storage/ZeedzINOCollection)
            signer.unlink(ZeedzINO.CollectionPublicPath)
		    signer.link<&ZeedzINO.Collection{NonFungibleToken.CollectionPublic,ZeedzINO.ZeedzCollectionPublic}>(
			    /public/ZeedzINOCollection,
			    target: /storage/ZeedzINOCollection
		    )
	    }

        self.storefront = getAccount(storefrontAddress)
            .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
            .borrow()
            ?? panic(""Could not borrow Storefront from provided address"")

        self.listing = self.storefront.borrowListing(listingResourceID: listingResourceID)
            ?? panic(""No Offer with that ID in Storefront"")
        let price = self.listing.getDetails().salePrice

        assert(buyPrice == price, message: ""buyPrice is NOT same with salePrice"")

        let flowTokenVault = signer.borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)
            ?? panic(""Cannot borrow FlowToken vault from signer storage"")
        self.paymentVault <- flowTokenVault.withdraw(amount: price)

        self.nftReceiver = signer.borrow<&ZeedzINO.Collection{NonFungibleToken.Receiver}>(from: /storage/ZeedzINOCollection)
            ?? panic(""Cannot borrow NFT collection receiver from account"")

        self.adminRef= admin.getCapability(ZeedzINO.AdminPrivatePath)
            .borrow<&ZeedzINO.Administrator>()!

        self.nftCollection = signer.getCapability(ZeedzINO.CollectionPublicPath).borrow<&{ZeedzINO.ZeedzCollectionPublic}>() 
            ?? panic(""Could not borrow ZeedzCollectionPublic"")
    }

    execute {
        let item <- self.listing.purchase(payment: <-self.paymentVault)

        let zeedleID = item.id

        self.nftReceiver.deposit(token: <-item)

        let zeedleRef = self.nftCollection.borrowZeedle(id: zeedleID)
            ?? panic(""No such zeedleID in that collection"")

        self.adminRef.increaseOffset(zeedleRef: zeedleRef, amount: UInt64(Int(buyPrice) * 420))

        // Be kind and recycle
        self.storefront.cleanup(listingResourceID: listingResourceID)
        ZeedzMarketplace.removeListing(id: listingResourceID)
    }

}"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import FUSD from 0x0
import FungibleToken from 0x0

transaction(saleItemID: UInt64, saleItemPrice: UFix64) {
    let fusdReceiver: Capability<&FUSD.Vault{FungibleToken.Receiver}>
    let nftProvider: Capability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
    let storefront: &NFTStorefront.Storefront
    let storefrontPublic: Capability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>

    prepare(signer: AuthAccount) {
        // Create Storefront if it doesn't exist
        if signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {
            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront
            signer.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)
            signer.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath,
                target: NFTStorefront.StorefrontStoragePath)
        }

        // We need a provider capability, but one is not provided by default so we create one if needed.
        let nftCollectionProviderPrivatePath = /private/zeedzINONFTCollectionProviderForNFTStorefront
        if !signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!.check() {
            signer.link<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath, target: ZeedzINO.CollectionStoragePath)
        }

        self.fusdReceiver = signer.getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver)!
        assert(self.fusdReceiver.borrow() != nil, message: ""Missing or mis-typed FUSD receiver"")

        self.nftProvider = signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!
        assert(self.nftProvider.borrow() != nil, message: ""Missing or mis-typed ZeedzINO.Collection provider"")

        self.storefront = signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)
            ?? panic(""Missing or mis-typed NFTStorefront Storefront"")

        self.storefrontPublic = signer.getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
        assert(self.storefrontPublic.borrow() != nil, message: ""Could not borrow public storefront from address"")
    }

    execute {
        // Remove old listing
        if let listingID = ZeedzMarketplace.getListingID(nftType: Type<@ZeedzINO.NFT>(), nftID: saleItemID) {
            let listingIDs = self.storefront.getListingIDs()
            if listingIDs.contains(listingID) {
                self.storefront.removeListing(listingResourceID: listingID)
            }
            ZeedzMarketplace.removeListing(id: listingID)
        }

        // Create SaleCuts
        var saleCuts: [NFTStorefront.SaleCut] = []
        var remainingPrice = saleItemPrice
        if let requirements = ZeedzMarketplace.getVaultTypeSaleCutRequirements(vaultType: Type<@FUSD.Vault>()) {
            for requirement in requirements {
                let price = saleItemPrice * requirement.ratio
                saleCuts.append(NFTStorefront.SaleCut(
                    receiver: requirement.receiver,
                    amount: price
                ))
                remainingPrice = remainingPrice - price
            }
        }
        saleCuts.append(NFTStorefront.SaleCut(
            receiver: self.fusdReceiver,
            amount: remainingPrice
        ))

        // Add listing
        let id = self.storefront.createListing(
            nftProviderCapability: self.nftProvider,
            nftType: Type<@ZeedzINO.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@FUSD.Vault>(),
            saleCuts: saleCuts
        )
        ZeedzMarketplace.addListing(id: id, storefrontPublicCapability: self.storefrontPublic)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

transaction(saleItemID: UInt64, saleItemPrice: UFix64) {
    let flowTokenReceiver: Capability<&FlowToken.Vault{FungibleToken.Receiver}>
    let nftProvider: Capability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
    let storefront: &NFTStorefront.Storefront
    let storefrontPublic: Capability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>

    prepare(signer: AuthAccount) {
        // Create Storefront if it doesn't exist
        if signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {
            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront
            signer.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)
            signer.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath,
                target: NFTStorefront.StorefrontStoragePath)
        }

        // We need a provider capability, but one is not provided by default so we create one if needed.
        let nftCollectionProviderPrivatePath = /private/zeedzINONFTCollectionProviderForNFTStorefront
        if !signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!.check() {
            signer.link<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath, target: ZeedzINO.CollectionStoragePath)
        }

        self.flowTokenReceiver = signer.getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)!
        assert(self.flowTokenReceiver.borrow() != nil, message: ""Missing or mis-typed FlowToken receiver"")

        self.nftProvider = signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!
        assert(self.nftProvider.borrow() != nil, message: ""Missing or mis-typed ZeedzINO.Collection provider"")

        self.storefront = signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)
            ?? panic(""Missing or mis-typed NFTStorefront Storefront"")

        self.storefrontPublic = signer.getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
        assert(self.storefrontPublic.borrow() != nil, message: ""Could not borrow public storefront from address"")
    }

    execute {
        // Remove old listing
        if let listingID = ZeedzMarketplace.getListingID(nftType: Type<@ZeedzINO.NFT>(), nftID: saleItemID) {
            let listingIDs = self.storefront.getListingIDs()
            if listingIDs.contains(listingID) {
                self.storefront.removeListing(listingResourceID: listingID)
            }
            ZeedzMarketplace.removeListing(id: listingID)
        }

        // Create SaleCuts
        var saleCuts: [NFTStorefront.SaleCut] = []
        var remainingPrice = saleItemPrice
        if let requirements = ZeedzMarketplace.getVaultTypeSaleCutRequirements(vaultType: Type<@FlowToken.Vault>()) {
            for requirement in requirements {
                let price = saleItemPrice * requirement.ratio
                saleCuts.append(NFTStorefront.SaleCut(
                    receiver: requirement.receiver,
                    amount: price
                ))
                remainingPrice = remainingPrice - price
            }
        }
        saleCuts.append(NFTStorefront.SaleCut(
            receiver: self.flowTokenReceiver,
            amount: remainingPrice
        ))

        // Add listing
        let id = self.storefront.createListing(
            nftProviderCapability: self.nftProvider,
            nftType: Type<@ZeedzINO.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@FlowToken.Vault>(),
            saleCuts: saleCuts
        )
        ZeedzMarketplace.addListing(id: id, storefrontPublicCapability: self.storefrontPublic)
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import FUSD from 0x0
import FungibleToken from 0x0

transaction(saleItemID: UInt64, saleItemPrice: UFix64) {
    let fusdReceiver: Capability<&FUSD.Vault{FungibleToken.Receiver}>
    let nftProvider: Capability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
    let storefront: &NFTStorefront.Storefront
    let storefrontPublic: Capability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>
    prepare(signer: AuthAccount) {
        // Create Storefront if it doesn't exist
        if signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {
            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront
            signer.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)
            signer.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath,
                target: NFTStorefront.StorefrontStoragePath)
        }
        // We need a provider capability, but one is not provided by default so we create one if needed.
        let nftCollectionProviderPrivatePath = /private/zeedzINONFTCollectionProviderForNFTStorefront
        if !signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!.check() {
            signer.link<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath, target: ZeedzINO.CollectionStoragePath)
        }
        // Initialize vault capability if it isn't already initialized
        if signer.borrow<&FUSD.Vault>(from: /storage/fusdVault) == nil {
            signer.save(<-FUSD.createEmptyVault(), to: /storage/fusdVault)
            signer.link<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver, target: /storage/fusdVault)
            signer.link<&FUSD.Vault{FungibleToken.Balance}>(/public/fusdBalance, target: /storage/fusdVault)
        }
        self.fusdReceiver = signer.getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver)!
        assert(self.fusdReceiver.borrow() != nil, message: ""Missing or mis-typed FUSD receiver"")
        self.nftProvider = signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!
        assert(self.nftProvider.borrow() != nil, message: ""Missing or mis-typed ZeedzINO.Collection provider"")
        self.storefront = signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)
            ?? panic(""Missing or mis-typed NFTStorefront Storefront"")
        self.storefrontPublic = signer.getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
        assert(self.storefrontPublic.borrow() != nil, message: ""Could not borrow public storefront from address"")
    }
    execute {
        // Remove old listing
        if let listingID = ZeedzMarketplace.getListingID(nftType: Type<@ZeedzINO.NFT>(), nftID: saleItemID) {
            let listingIDs = self.storefront.getListingIDs()
            if listingIDs.contains(listingID) {
                self.storefront.removeListing(listingResourceID: listingID)
            }
            ZeedzMarketplace.removeListing(id: listingID)
        }
        // Create SaleCuts
        var saleCuts: [NFTStorefront.SaleCut] = []
        var remainingPrice = saleItemPrice
        if let requirements = ZeedzMarketplace.getVaultTypeSaleCutRequirements(vaultType: Type<@FUSD.Vault>()) {
            for requirement in requirements {
                let price = saleItemPrice * requirement.ratio
                saleCuts.append(NFTStorefront.SaleCut(
                    receiver: requirement.receiver,
                    amount: price
                ))
                remainingPrice = remainingPrice - price
            }
        }
        saleCuts.append(NFTStorefront.SaleCut(
            receiver: self.fusdReceiver,
            amount: remainingPrice
        ))
        // Add listing
        let id = self.storefront.createListing(
            nftProviderCapability: self.nftProvider,
            nftType: Type<@ZeedzINO.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@FUSD.Vault>(),
            saleCuts: saleCuts
        )
        ZeedzMarketplace.addListing(id: id, storefrontPublicCapability: self.storefrontPublic)
    }
}"
t.0000000000000000,"import ZeedzMarketplace from 0x0
import FlowToken from 0x0
import FungibleToken from 0x0

// This transaction creates SaleCutRequirements of ZeedzMarketplace for NFT & Zeedz
transaction(marketCut: Address, offsetCut: Address) {

    prepare(signer: AuthAccount) {
        let marketRecipient = marketCut
        let marketRatio = 0.025 // 2.5%
        let offsetRecipient = offsetCut
        let offsetRatio = 0.025 // 2.5%

        assert(offsetRatio + marketRatio <= 1.0, message: ""total of ratio must be less than or equal to 1.0"")

        let admin = signer.borrow<&ZeedzMarketplace.Administrator>(from: ZeedzMarketplace.ZeedzMarketplaceAdminStoragePath)
            ?? panic(""Cannot borrow marketplace admin"")

        let requirements: [ZeedzMarketplace.SaleCutRequirement] = []

        // market SaleCut
        if marketRatio > 0.0 {
            let marketFlowTokenReceiver = getAccount(marketCut).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            assert(marketFlowTokenReceiver.borrow() != nil, message: ""Missing or mis-typed market FlowToken receiver"")
            requirements.append(ZeedzMarketplace.SaleCutRequirement(receiver: marketFlowTokenReceiver, ratio: marketRatio))
        }

        // offset SaleCut
        if offsetRatio > 0.0 {
            let nftFlowTokenReceiver = getAccount(offsetCut).getCapability<&FlowToken.Vault{FungibleToken.Receiver}>(/public/flowTokenReceiver)
            assert(nftFlowTokenReceiver.borrow() != nil, message: ""Missing or mis-typed NFT FlowToken receiver"")
            requirements.append(ZeedzMarketplace.SaleCutRequirement(receiver: nftFlowTokenReceiver, ratio: offsetRatio))
        }

        admin.updateSaleCutRequirement(requirements: requirements, vaultType: Type<@FlowToken.Vault>())
    }
}"
t.0000000000000000,"import ZeedzMarketplace from 0x0
import FUSD from 0x0
import FungibleToken from 0x0

// This transaction creates SaleCutRequirements of ZeedzMarketplace for NFT & Zeedz
transaction(marketCut: Address, offsetCut: Address) {

    prepare(signer: AuthAccount) {
        let marketRecipient = marketCut
        let marketRatio = 0.025 // 2.5%
        let offsetRecipient = offsetCut
        let offsetRatio = 0.025 // 2.5%

        assert(offsetRatio + marketRatio <= 1.0, message: ""total of ratio must be less than or equal to 1.0"")

        let admin = signer.borrow<&ZeedzMarketplace.Administrator>(from: ZeedzMarketplace.ZeedzMarketplaceAdminStoragePath)
            ?? panic(""Cannot borrow marketplace admin"")

        let requirements: [ZeedzMarketplace.SaleCutRequirement] = []

        // market SaleCut
        if marketRatio > 0.0 {
            let marketFusdReceiver = getAccount(marketCut).getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver)
            assert(marketFusdReceiver.borrow() != nil, message: ""Missing or mis-typed market FUSD receiver"")
            requirements.append(ZeedzMarketplace.SaleCutRequirement(receiver: marketFusdReceiver, ratio: marketRatio))
        }

        // offset SaleCut
        if offsetRatio > 0.0 {
            let nftFusdReceiver = getAccount(offsetCut).getCapability<&FUSD.Vault{FungibleToken.Receiver}>(/public/fusdReceiver)
            assert(nftFusdReceiver.borrow() != nil, message: ""Missing or mis-typed NFT FUSD receiver"")
            requirements.append(ZeedzMarketplace.SaleCutRequirement(receiver: nftFusdReceiver, ratio: offsetRatio))
        }

         admin.updateSaleCutRequirement(requirements: requirements, vaultType: Type<@FUSD.Vault>())
    }
}"
t.0000000000000000,"import NonFungibleToken from 0x0
import NFTStorefront from 0x0
import ZeedzMarketplace from 0x0
import ZeedzINO from 0x0
import FiatToken from 0x0
import FungibleToken from 0x0

transaction(saleItemID: UInt64, saleItemPrice: UFix64) {
    let fiatTokenReceiver: Capability<&FiatToken.Vault{FungibleToken.Receiver}>
    let nftProvider: Capability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>
    let storefront: &NFTStorefront.Storefront
    let storefrontPublic: Capability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>

    prepare(signer: AuthAccount) {
        // Create Storefront if it doesn't exist
        if signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {
            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront
            signer.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)
            signer.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(
                NFTStorefront.StorefrontPublicPath,
                target: NFTStorefront.StorefrontStoragePath)
        }

        // We need a provider capability, but one is not provided by default so we create one if needed.
        let nftCollectionProviderPrivatePath = /private/zeedzINONFTCollectionProviderForNFTStorefront
        if !signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!.check() {
            signer.link<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath, target: ZeedzINO.CollectionStoragePath)
        }

        self.fiatTokenReceiver = signer.getCapability<&FiatToken.Vault{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)!
        assert(self.fiatTokenReceiver.borrow() != nil, message: ""Missing or mis-typed FiatToken receiver"")

        self.nftProvider = signer.getCapability<&ZeedzINO.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(nftCollectionProviderPrivatePath)!
        assert(self.nftProvider.borrow() != nil, message: ""Missing or mis-typed ZeedzINO.Collection provider"")

        self.storefront = signer.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)
            ?? panic(""Missing or mis-typed NFTStorefront Storefront"")

        self.storefrontPublic = signer.getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath)
        assert(self.storefrontPublic.borrow() != nil, message: ""Could not borrow public storefront from address"")
    }

    execute {
        // Remove old listing
        if let listingID = ZeedzMarketplace.getListingID(nftType: Type<@ZeedzINO.NFT>(), nftID: saleItemID) {
            let listingIDs = self.storefront.getListingIDs()
            if listingIDs.contains(listingID) {
                self.storefront.removeListing(listingResourceID: listingID)
            }
            ZeedzMarketplace.removeListing(id: listingID)
        }

        // Create SaleCuts
        var saleCuts: [NFTStorefront.SaleCut] = []
        var remainingPrice = saleItemPrice
        if let requirements = ZeedzMarketplace.getVaultTypeSaleCutRequirements(vaultType: Type<@FiatToken.Vault>()) {
            for requirement in requirements {
                let price = saleItemPrice * requirement.ratio
                saleCuts.append(NFTStorefront.SaleCut(
                    receiver: requirement.receiver,
                    amount: price
                ))
                remainingPrice = remainingPrice - price
            }
        }
        saleCuts.append(NFTStorefront.SaleCut(
            receiver: self.fiatTokenReceiver,
            amount: remainingPrice
        ))

        // Add listing
        let id = self.storefront.createListing(
            nftProviderCapability: self.nftProvider,
            nftType: Type<@ZeedzINO.NFT>(),
            nftID: saleItemID,
            salePaymentVaultType: Type<@FiatToken.Vault>(),
            saleCuts: saleCuts
        )
        ZeedzMarketplace.addListing(id: id, storefrontPublicCapability: self.storefrontPublic)
    }
}"
t.0000000000000000,"import ZeedzMarketplace from 0x0
import FiatToken from 0x0
import FungibleToken from 0x0

// This transaction creates SaleCutRequirements of ZeedzMarketplace for NFT & Zeedz
transaction(marketCut: Address, offsetCut: Address) {

    prepare(signer: AuthAccount) {
        let marketRecipient = marketCut
        let marketRatio = 0.025 // 2.5%
        let offsetRecipient = offsetCut
        let offsetRatio = 0.025 // 2.5%

        assert(offsetRatio + marketRatio <= 1.0, message: ""total of ratio must be less than or equal to 1.0"")

        let admin = signer.borrow<&ZeedzMarketplace.Administrator>(from: ZeedzMarketplace.ZeedzMarketplaceAdminStoragePath)
            ?? panic(""Cannot borrow marketplace admin"")

        let requirements: [ZeedzMarketplace.SaleCutRequirement] = []

        // market SaleCut
        if marketRatio > 0.0 {
            let marketFiatTokenReceiver = getAccount(marketCut).getCapability<&FiatToken.Vault{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)
            assert(marketFiatTokenReceiver.borrow() != nil, message: ""Missing or mis-typed market FiatToken receiver"")
            requirements.append(ZeedzMarketplace.SaleCutRequirement(receiver: marketFiatTokenReceiver, ratio: marketRatio))
        }

        // offset SaleCut
        if offsetRatio > 0.0 {
            let nftFiatTokenReceiver = getAccount(offsetCut).getCapability<&FiatToken.Vault{FungibleToken.Receiver}>(FiatToken.VaultReceiverPubPath)
            assert(nftFiatTokenReceiver.borrow() != nil, message: ""Missing or mis-typed NFT FiatToken receiver"")
            requirements.append(ZeedzMarketplace.SaleCutRequirement(receiver: nftFiatTokenReceiver, ratio: offsetRatio))
        }

         admin.updateSaleCutRequirement(requirements: requirements, vaultType: Type<@FiatToken.Vault>())
    }
}"